(function(a) {
    if (typeof define === "function" && define.amd) {
        define(["./dependencyLibs/inputmask.dependencyLib", "./global/window", "./global/document"], a)
    } else if (typeof exports === "object") {
        module.exports = a(require("./dependencyLibs/inputmask.dependencyLib"), require("./global/window"), require("./global/document"))
    } else {
        window.Inputmask = a(window.dependencyLib || jQuery, window, document)
    }
}(function($, Y, Z, ba) {
    var bb = navigator.userAgent,
        mobile = isInputEventSupported("touchstart"),
        iemobile = /iemobile/i.test(bb),
        iphone = /iphone/i.test(bb) && !iemobile;

    function Inputmask(a, b, c) {
        if (!(this instanceof Inputmask)) {
            return new Inputmask(a, b, c)
        }
        this.el = ba;
        this.events = {};
        this.maskset = ba;
        this.refreshValue = false;
        if (c !== true) {
            if ($.isPlainObject(a)) {
                b = a
            } else {
                b = b || {};
                if (a) b.alias = a
            }
            this.opts = $.extend(true, {}, this.defaults, b);
            this.noMasksCache = b && b.definitions !== ba;
            this.userOptions = b || {};
            this.isRTL = this.opts.numericInput;
            resolveAlias(this.opts.alias, b, this.opts)
        }
    }
    Inputmask.prototype = {
        dataAttribute: "data-inputmask",
        defaults: {
            placeholder: "_",
            optionalmarker: ["[", "]"],
            quantifiermarker: ["{", "}"],
            groupmarker: ["(", ")"],
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null,
            regex: null,
            oncomplete: $.noop,
            onincomplete: $.noop,
            oncleared: $.noop,
            repeat: 0,
            greedy: true,
            autoUnmask: false,
            removeMaskOnSubmit: false,
            clearMaskOnLostFocus: true,
            insertMode: true,
            clearIncomplete: false,
            alias: null,
            onKeyDown: $.noop,
            onBeforeMask: null,
            onBeforePaste: function(a, b) {
                return $.isFunction(b.onBeforeMask) ? b.onBeforeMask.call(this, a, b) : a
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: true,
            showMaskOnHover: true,
            onKeyValidation: $.noop,
            skipOptionalPartCharacter: " ",
            numericInput: false,
            rightAlign: false,
            undoOnEscape: true,
            radixPoint: "",
            _radixDance: false,
            groupSeparator: "",
            keepStatic: null,
            positionCaretOnTab: true,
            tabThrough: false,
            supportsInputType: ["text", "tel", "password", "search"],
            ignorables: [8, 9, 13, 19, 27, 33, 34, 35, 36, 37, 38, 39, 40, 45, 46, 93, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 0, 229],
            isComplete: null,
            canClearPosition: $.noop,
            preValidation: null,
            postValidation: null,
            staticDefinitionSymbol: ba,
            jitMasking: false,
            nullable: true,
            inputEventOnly: false,
            noValuePatching: false,
            positionCaretOnClick: "lvp",
            casing: null,
            inputmode: "verbatim",
            colorMask: false,
            disablePredictiveText: false,
            importDataAttributes: true
        },
        definitions: {
            "9": {
                validator: "[0-9\uFF11-\uFF19]",
                definitionSymbol: "*"
            },
            "a": {
                validator: "[A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]",
                definitionSymbol: "*"
            },
            "*": {
                validator: "[0-9\uFF11-\uFF19A-Za-z\u0410-\u044F\u0401\u0451\u00C0-\u00FF\u00B5]"
            }
        },
        aliases: {},
        masksCache: {},
        mask: function(h) {
            var i = this;

            function importAttributeOptions(c, d, e, f) {
                if (d.importDataAttributes === true) {
                    var g = c.getAttribute(f),
                        option, dataoptions, optionData, p;

                    function importOption(a, b) {
                        b = b !== ba ? b : c.getAttribute(f + "-" + a);
                        if (b !== null) {
                            if (typeof b === "string") {
                                if (a.indexOf("on") === 0) b = Y[b];
                                else if (b === "false") b = false;
                                else if (b === "true") b = true
                            }
                            e[a] = b
                        }
                    }
                    if (g && g !== "") {
                        g = g.replace(/'/g, '"');
                        dataoptions = JSON.parse("{" + g + "}")
                    }
                    if (dataoptions) {
                        optionData = ba;
                        for (p in dataoptions) {
                            if (p.toLowerCase() === "alias") {
                                optionData = dataoptions[p];
                                break
                            }
                        }
                    }
                    importOption("alias", optionData);
                    if (e.alias) {
                        resolveAlias(e.alias, e, d)
                    }
                    for (option in d) {
                        if (dataoptions) {
                            optionData = ba;
                            for (p in dataoptions) {
                                if (p.toLowerCase() === option.toLowerCase()) {
                                    optionData = dataoptions[p];
                                    break
                                }
                            }
                        }
                        importOption(option, optionData)
                    }
                }
                $.extend(true, d, e);
                if (c.dir === "rtl" || d.rightAlign) {
                    c.style.textAlign = "right"
                }
                if (c.dir === "rtl" || d.numericInput) {
                    c.dir = "ltr";
                    c.removeAttribute("dir");
                    d.isRTL = true
                }
                return Object.keys(e).length
            }
            if (typeof h === "string") {
                h = Z.getElementById(h) || Z.querySelectorAll(h)
            }
            h = h.nodeName ? [h] : h;
            $.each(h, function(a, b) {
                var c = $.extend(true, {}, i.opts);
                if (importAttributeOptions(b, c, $.extend(true, {}, i.userOptions), i.dataAttribute)) {
                    var d = generateMaskSet(c, i.noMasksCache);
                    if (d !== ba) {
                        if (b.inputmask !== ba) {
                            b.inputmask.opts.autoUnmask = true;
                            b.inputmask.remove()
                        }
                        b.inputmask = new Inputmask(ba, ba, true);
                        b.inputmask.opts = c;
                        b.inputmask.noMasksCache = i.noMasksCache;
                        b.inputmask.userOptions = $.extend(true, {}, i.userOptions);
                        b.inputmask.isRTL = c.isRTL || c.numericInput;
                        b.inputmask.el = b;
                        b.inputmask.maskset = d;
                        $.data(b, "_inputmask_opts", c);
                        maskScope.call(b.inputmask, {
                            "action": "mask"
                        })
                    }
                }
            });
            return h && h[0] ? (h[0].inputmask || this) : this
        },
        option: function(a, b) {
            if (typeof a === "string") {
                return this.opts[a]
            } else if (typeof a === "object") {
                $.extend(this.userOptions, a);
                if (this.el && b !== true) {
                    this.mask(this.el)
                }
                return this
            }
        },
        unmaskedvalue: function(a) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "unmaskedvalue",
                "value": a
            })
        },
        remove: function() {
            return maskScope.call(this, {
                "action": "remove"
            })
        },
        getemptymask: function() {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "getemptymask"
            })
        },
        hasMaskedValue: function() {
            return !this.opts.autoUnmask
        },
        isComplete: function() {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "isComplete"
            })
        },
        getmetadata: function() {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "getmetadata"
            })
        },
        isValid: function(a) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "isValid",
                "value": a
            })
        },
        format: function(a, b) {
            this.maskset = this.maskset || generateMaskSet(this.opts, this.noMasksCache);
            return maskScope.call(this, {
                "action": "format",
                "value": a,
                "metadata": b
            })
        },
        setValue: function(a) {
            if (this.el) {
                $(this.el).trigger("setvalue", [a])
            }
        },
        analyseMask: function(h, i, j) {
            var k = /(?:[?*+]|\{[0-9\+\*]+(?:,[0-9\+\*]*)?(?:\|[0-9\+\*]*)?\})|[^.?*+^${[]()|\\]+|./g,
                regexTokenizer = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g,
                escaped = false,
                currentToken = new MaskToken(),
                match, m, openenings = [],
                maskTokens = [],
                openingToken, currentOpeningToken, alternator, lastMatch, groupToken;

            function MaskToken(a, b, c, d) {
                this.matches = [];
                this.openGroup = a || false;
                this.alternatorGroup = false;
                this.isGroup = a || false;
                this.isOptional = b || false;
                this.isQuantifier = c || false;
                this.isAlternator = d || false;
                this.quantifier = {
                    min: 1,
                    max: 1
                }
            }

            function insertTestDefinition(c, d, e) {
                e = e !== ba ? e : c.matches.length;
                var f = c.matches[e - 1];
                if (i) {
                    if (d.indexOf("[") === 0 || (escaped && /\\d|\\s|\\w]/i.test(d)) || d === ".") {
                        c.matches.splice(e++, 0, {
                            fn: new RegExp(d, j.casing ? "i" : ""),
                            optionality: c.isOptional,
                            newBlockMarker: f === ba || f.def !== d,
                            casing: null,
                            def: d,
                            placeholder: ba,
                            nativeDef: d
                        })
                    } else {
                        if (escaped) d = d[d.length - 1];
                        $.each(d.split(""), function(a, b) {
                            f = c.matches[e - 1];
                            c.matches.splice(e++, 0, {
                                fn: null,
                                optionality: c.isOptional,
                                newBlockMarker: f === ba || (f.def !== b && f.fn !== null),
                                casing: null,
                                def: j.staticDefinitionSymbol || b,
                                placeholder: j.staticDefinitionSymbol !== ba ? b : ba,
                                nativeDef: b
                            })
                        })
                    }
                    escaped = false
                } else {
                    var g = (j.definitions ? j.definitions[d] : ba) || Inputmask.prototype.definitions[d];
                    if (g && !escaped) {
                        c.matches.splice(e++, 0, {
                            fn: g.validator ? typeof g.validator == "string" ? new RegExp(g.validator, j.casing ? "i" : "") : new function() {
                                this.test = g.validator
                            } : new RegExp("."),
                            optionality: c.isOptional,
                            newBlockMarker: f === ba || f.def !== (g.definitionSymbol || d),
                            casing: g.casing,
                            def: g.definitionSymbol || d,
                            placeholder: g.placeholder,
                            nativeDef: d
                        })
                    } else {
                        c.matches.splice(e++, 0, {
                            fn: null,
                            optionality: c.isOptional,
                            newBlockMarker: f === ba || (f.def !== d && f.fn !== null),
                            casing: null,
                            def: j.staticDefinitionSymbol || d,
                            placeholder: j.staticDefinitionSymbol !== ba ? d : ba,
                            nativeDef: d
                        });
                        escaped = false
                    }
                }
            }

            function verifyGroupMarker(d) {
                if (d && d.matches) {
                    $.each(d.matches, function(a, b) {
                        var c = d.matches[a + 1];
                        if ((c === ba || (c.matches === ba || c.isQuantifier === false)) && b && b.isGroup) {
                            b.isGroup = false;
                            if (!i) {
                                insertTestDefinition(b, j.groupmarker[0], 0);
                                if (b.openGroup !== true) {
                                    insertTestDefinition(b, j.groupmarker[1])
                                }
                            }
                        }
                        verifyGroupMarker(b)
                    })
                }
            }

            function defaultCase() {
                if (openenings.length > 0) {
                    currentOpeningToken = openenings[openenings.length - 1];
                    insertTestDefinition(currentOpeningToken, m);
                    if (currentOpeningToken.isAlternator) {
                        alternator = openenings.pop();
                        for (var a = 0; a < alternator.matches.length; a++) {
                            alternator.matches[a].isGroup = false
                        }
                        if (openenings.length > 0) {
                            currentOpeningToken = openenings[openenings.length - 1];
                            currentOpeningToken.matches.push(alternator)
                        } else {
                            currentToken.matches.push(alternator)
                        }
                    }
                } else {
                    insertTestDefinition(currentToken, m)
                }
            }

            function reverseTokens(b) {
                function reverseStatic(a) {
                    if (a === j.optionalmarker[0]) a = j.optionalmarker[1];
                    else if (a === j.optionalmarker[1]) a = j.optionalmarker[0];
                    else if (a === j.groupmarker[0]) a = j.groupmarker[1];
                    else if (a === j.groupmarker[1]) a = j.groupmarker[0];
                    return a
                }
                b.matches = b.matches.reverse();
                for (var c in b.matches) {
                    if (b.matches.hasOwnProperty(c)) {
                        var d = parseInt(c);
                        if (b.matches[c].isQuantifier && b.matches[d + 1] && b.matches[d + 1].isGroup) {
                            var e = b.matches[c];
                            b.matches.splice(c, 1);
                            b.matches.splice(d + 1, 0, e)
                        }
                        if (b.matches[c].matches !== ba) {
                            b.matches[c] = reverseTokens(b.matches[c])
                        } else {
                            b.matches[c] = reverseStatic(b.matches[c])
                        }
                    }
                }
                return b
            }
            if (i) {
                j.optionalmarker[0] = ba;
                j.optionalmarker[1] = ba
            }
            while (match = i ? regexTokenizer.exec(h) : k.exec(h)) {
                m = match[0];
                if (i) {
                    switch (m.charAt(0)) {
                        case "?":
                            m = "{0,1}";
                            break;
                        case "+":
                        case "*":
                            m = "{" + m + "}";
                            break
                    }
                }
                if (escaped) {
                    defaultCase();
                    continue
                }
                switch (m.charAt(0)) {
                    case j.escapeChar:
                        escaped = true;
                        if (i) {
                            defaultCase()
                        }
                        break;
                    case j.optionalmarker[1]:
                    case j.groupmarker[1]:
                        openingToken = openenings.pop();
                        openingToken.openGroup = false;
                        if (openingToken !== ba) {
                            if (openenings.length > 0) {
                                currentOpeningToken = openenings[openenings.length - 1];
                                currentOpeningToken.matches.push(openingToken);
                                if (currentOpeningToken.isAlternator) {
                                    alternator = openenings.pop();
                                    for (var l = 0; l < alternator.matches.length; l++) {
                                        alternator.matches[l].isGroup = false;
                                        alternator.matches[l].alternatorGroup = false
                                    }
                                    if (openenings.length > 0) {
                                        currentOpeningToken = openenings[openenings.length - 1];
                                        currentOpeningToken.matches.push(alternator)
                                    } else {
                                        currentToken.matches.push(alternator)
                                    }
                                }
                            } else {
                                currentToken.matches.push(openingToken)
                            }
                        } else defaultCase();
                        break;
                    case j.optionalmarker[0]:
                        openenings.push(new MaskToken(false, true));
                        break;
                    case j.groupmarker[0]:
                        openenings.push(new MaskToken(true));
                        break;
                    case j.quantifiermarker[0]:
                        var n = new MaskToken(false, false, true);
                        m = m.replace(/[{}]/g, "");
                        var o = m.split("|"),
                            mq = o[0].split(","),
                            mq0 = isNaN(mq[0]) ? mq[0] : parseInt(mq[0]),
                            mq1 = mq.length === 1 ? mq0 : (isNaN(mq[1]) ? mq[1] : parseInt(mq[1]));
                        if (mq1 === "*" || mq1 === "+") {
                            mq0 = mq1 === "*" ? 0 : 1
                        }
                        n.quantifier = {
                            min: mq0,
                            max: mq1,
                            jit: o[1]
                        };
                        if (openenings.length > 0) {
                            var p = openenings[openenings.length - 1].matches;
                            match = p.pop();
                            if (!match.isGroup) {
                                groupToken = new MaskToken(true);
                                groupToken.matches.push(match);
                                match = groupToken
                            }
                            p.push(match);
                            p.push(n)
                        } else {
                            match = currentToken.matches.pop();
                            if (!match.isGroup) {
                                if (i && match.fn === null) {
                                    if (match.def === ".") match.fn = new RegExp(match.def, j.casing ? "i" : "")
                                }
                                groupToken = new MaskToken(true);
                                groupToken.matches.push(match);
                                match = groupToken
                            }
                            currentToken.matches.push(match);
                            currentToken.matches.push(n)
                        }
                        break;
                    case j.alternatormarker:
                        if (openenings.length > 0) {
                            currentOpeningToken = openenings[openenings.length - 1];
                            var q = currentOpeningToken.matches[currentOpeningToken.matches.length - 1];
                            if (currentOpeningToken.openGroup && (q.matches === ba || (q.isGroup === false && q.isAlternator === false))) {
                                lastMatch = openenings.pop()
                            } else {
                                lastMatch = currentOpeningToken.matches.pop()
                            }
                        } else {
                            lastMatch = currentToken.matches.pop()
                        }
                        if (lastMatch.isAlternator) {
                            openenings.push(lastMatch)
                        } else {
                            if (lastMatch.alternatorGroup) {
                                alternator = openenings.pop();
                                lastMatch.alternatorGroup = false
                            } else {
                                alternator = new MaskToken(false, false, false, true)
                            }
                            alternator.matches.push(lastMatch);
                            openenings.push(alternator);
                            if (lastMatch.openGroup) {
                                lastMatch.openGroup = false;
                                var r = new MaskToken(true);
                                r.alternatorGroup = true;
                                openenings.push(r)
                            }
                        }
                        break;
                    default:
                        defaultCase()
                }
            }
            while (openenings.length > 0) {
                openingToken = openenings.pop();
                currentToken.matches.push(openingToken)
            }
            if (currentToken.matches.length > 0) {
                verifyGroupMarker(currentToken);
                maskTokens.push(currentToken)
            }
            if (j.numericInput || j.isRTL) {
                reverseTokens(maskTokens[0])
            }
            return maskTokens
        }
    };
    Inputmask.extendDefaults = function(a) {
        $.extend(true, Inputmask.prototype.defaults, a)
    };
    Inputmask.extendDefinitions = function(a) {
        $.extend(true, Inputmask.prototype.definitions, a)
    };
    Inputmask.extendAliases = function(a) {
        $.extend(true, Inputmask.prototype.aliases, a)
    };
    Inputmask.format = function(a, b, c) {
        return Inputmask(b).format(a, c)
    };
    Inputmask.unmask = function(a, b) {
        return Inputmask(b).unmaskedvalue(a)
    };
    Inputmask.isValid = function(a, b) {
        return Inputmask(b).isValid(a)
    };
    Inputmask.remove = function(c) {
        if (typeof c === "string") {
            c = Z.getElementById(c) || Z.querySelectorAll(c)
        }
        c = c.nodeName ? [c] : c;
        $.each(c, function(a, b) {
            if (b.inputmask) b.inputmask.remove()
        })
    };
    Inputmask.setValue = function(c, d) {
        if (typeof c === "string") {
            c = Z.getElementById(c) || Z.querySelectorAll(c)
        }
        c = c.nodeName ? [c] : c;
        $.each(c, function(a, b) {
            if (b.inputmask) b.inputmask.setValue(d);
            else $(b).trigger("setvalue", [d])
        })
    };
    Inputmask.escapeRegex = function(a) {
        var b = ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"];
        return a.replace(new RegExp("(\\" + b.join("|\\") + ")", "gim"), "\\$1")
    };
    Inputmask.keyCode = {
        BACKSPACE: 8,
        BACKSPACE_SAFARI: 127,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        INSERT: 45,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38,
        X: 88,
        CONTROL: 17
    };

    function resolveAlias(a, b, c) {
        var d = Inputmask.prototype.aliases[a];
        if (d) {
            if (d.alias) resolveAlias(d.alias, ba, c);
            $.extend(true, c, d);
            $.extend(true, c, b);
            return true
        } else if (c.mask === null) {
            c.mask = a
        }
        return false
    }

    function generateMaskSet(g, h) {
        function generateMask(a, b, c) {
            var d = false;
            if (a === null || a === "") {
                d = c.regex !== null;
                if (d) {
                    a = c.regex;
                    a = a.replace(/^(\^)(.*)(\$)$/, "$2")
                } else {
                    d = true;
                    a = ".*"
                }
            }
            if (a.length === 1 && c.greedy === false && c.repeat !== 0) {
                c.placeholder = ""
            }
            if (c.repeat > 0 || c.repeat === "*" || c.repeat === "+") {
                var e = c.repeat === "*" ? 0 : (c.repeat === "+" ? 1 : c.repeat);
                a = c.groupmarker[0] + a + c.groupmarker[1] + c.quantifiermarker[0] + e + "," + c.repeat + c.quantifiermarker[1]
            }
            var f, maskdefKey = d ? "regex_" + c.regex : (c.numericInput ? a.split("").reverse().join("") : a);
            if (Inputmask.prototype.masksCache[maskdefKey] === ba || h === true) {
                f = {
                    "mask": a,
                    "maskToken": Inputmask.prototype.analyseMask(a, d, c),
                    "validPositions": {},
                    "_buffer": ba,
                    "buffer": ba,
                    "tests": {},
                    "excludes": {},
                    "metadata": b,
                    maskLength: ba
                };
                if (h !== true) {
                    Inputmask.prototype.masksCache[maskdefKey] = f;
                    f = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey])
                }
            } else f = $.extend(true, {}, Inputmask.prototype.masksCache[maskdefKey]);
            return f
        }
        var j;
        if ($.isFunction(g.mask)) {
            g.mask = g.mask(g)
        }
        if ($.isArray(g.mask)) {
            if (g.mask.length > 1) {
                if (g.keepStatic === null) {
                    g.keepStatic = "auto";
                    for (var i = 0; i < g.mask.length; i++) {
                        if (g.mask[i].charAt(0) !== g.mask[0].charAt(0)) {
                            g.keepStatic = true;
                            break
                        }
                    }
                }
                var k = g.groupmarker[0];
                $.each(g.isRTL ? g.mask.reverse() : g.mask, function(a, b) {
                    if (k.length > 1) {
                        k += g.groupmarker[1] + g.alternatormarker + g.groupmarker[0]
                    }
                    if (b.mask !== ba && !$.isFunction(b.mask)) {
                        k += b.mask
                    } else {
                        k += b
                    }
                });
                k += g.groupmarker[1];
                return generateMask(k, g.mask, g)
            } else g.mask = g.mask.pop()
        }
        if (g.mask && g.mask.mask !== ba && !$.isFunction(g.mask.mask)) {
            j = generateMask(g.mask.mask, g.mask, g)
        } else {
            j = generateMask(g.mask, g.mask, g)
        }
        return j
    };

    function isInputEventSupported(a) {
        var b = Z.createElement("input"),
            evName = "on" + a,
            isSupported = (evName in b);
        if (!isSupported) {
            b.setAttribute(evName, "return;");
            isSupported = typeof b[evName] === "function"
        }
        b = null;
        return isSupported
    }

    function maskScope(N, O, P) {
        O = O || this.maskset;
        P = P || this.opts;
        var Q = this,
            el = this.el,
            isRTL = this.isRTL,
            undoValue, $el, skipKeyPressEvent = false,
            skipInputEvent = false,
            ignorable = false,
            maxLength, mouseEnter = false,
            colorMask, trackCaret = false;

        function getMaskTemplate(a, b, c) {
            b = b || 0;
            var d = [],
                ndxIntlzr, pos = 0,
                test, testPos, lvp = getLastValidPosition();
            do {
                if (a === true && getMaskSet().validPositions[pos]) {
                    testPos = getMaskSet().validPositions[pos];
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    d.push(c === true ? testPos.input : c === false ? test.nativeDef : getPlaceholder(pos, test))
                } else {
                    testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                    test = testPos.match;
                    ndxIntlzr = testPos.locator.slice();
                    var e = P.jitMasking !== false ? P.jitMasking : test.jit;
                    if (e === false || e === ba || pos < lvp || (typeof e === "number" && isFinite(e) && e > pos)) {
                        d.push(c === false ? test.nativeDef : getPlaceholder(pos, test))
                    }
                }
                if (P.keepStatic === "auto") {
                    if (test.newBlockMarker && test.fn !== null) {
                        P.keepStatic = pos - 1
                    }
                }
                pos++
            } while ((maxLength === ba || pos < maxLength) && (test.fn !== null || test.def !== "") || b > pos);
            if (d[d.length - 1] === "") {
                d.pop()
            }
            if (c !== false || getMaskSet().maskLength === ba) getMaskSet().maskLength = pos - 1;
            return d
        }

        function getMaskSet() {
            return O
        }

        function resetMaskSet(a) {
            var b = getMaskSet();
            b.buffer = ba;
            if (a !== true) {
                b.validPositions = {};
                b.p = 0
            }
        }

        function getLastValidPosition(a, b, c) {
            var d = -1,
                after = -1,
                valids = c || getMaskSet().validPositions;
            if (a === ba) a = -1;
            for (var e in valids) {
                var f = parseInt(e);
                if (valids[f] && (b || valids[f].generatedInput !== true)) {
                    if (f <= a) d = f;
                    if (f >= a) after = f
                }
            }
            return (d === -1 || d == a) ? after : after == -1 ? d : (a - d) < (after - a) ? d : after
        }

        function stripValidPositions(d, e, f) {
            function IsEnclosedStatic(a) {
                var b = getMaskSet().validPositions[a];
                if (b !== ba && b.match.fn === null) {
                    var c = getMaskSet().validPositions[a - 1],
                        nextMatch = getMaskSet().validPositions[a + 1];
                    return c !== ba && nextMatch !== ba
                }
                return false
            }
            var i, startPos = d.begin,
                positionsClone = $.extend(true, {}, getMaskSet().validPositions),
                needsValidation = false;
            getMaskSet().p = d.begin;
            for (i = d.end - 1; i >= startPos; i--) {
                if (getMaskSet().validPositions[i] !== ba) {
                    if (e === true || ((getMaskSet().validPositions[i].match.optionality || !IsEnclosedStatic(i)) && P.canClearPosition(getMaskSet(), i, getLastValidPosition(ba, true), f, P) !== false)) {
                        delete getMaskSet().validPositions[i]
                    }
                }
            }
            resetMaskSet(true);
            for (i = startPos + 1; i <= getLastValidPosition();) {
                while (getMaskSet().validPositions[startPos] !== ba) startPos++;
                if (i < startPos) i = startPos + 1;
                if (getMaskSet().validPositions[i] !== ba || !isMask(i)) {
                    var t = getTestTemplate(i);
                    if (needsValidation === false && positionsClone[startPos] && positionsClone[startPos].match.def === t.match.def) {
                        getMaskSet().validPositions[startPos] = $.extend(true, {}, positionsClone[startPos]);
                        getMaskSet().validPositions[startPos].input = t.input;
                        delete getMaskSet().validPositions[i];
                        i++
                    } else if (positionCanMatchDefinition(startPos, t.match.def)) {
                        if (isValid(startPos, t.input || getPlaceholder(i), true) !== false) {
                            delete getMaskSet().validPositions[i];
                            i++;
                            needsValidation = true
                        }
                    } else if (!isMask(i)) {
                        i++;
                        startPos--
                    }
                    startPos++
                } else i++
            }
            if (f !== true) {
                i = getLastValidPosition(-1, true);
                while (getMaskSet().validPositions[i] && getMaskSet().validPositions[i].generatedInput === true) {
                    delete getMaskSet().validPositions[i--]
                }
            }
            resetMaskSet(true)
        }

        function determineTestTemplate(a, b, c) {
            a = a > 0 ? a - 1 : 0;
            var d, altTest = getTest(a, b),
                altArr = (altTest.alternation !== ba) ? altTest.locator[altTest.alternation].toString().split(",") : [];
            for (var e = 0; e < b.length; e++) {
                d = b[e];
                if (d.match && (((P.greedy && d.match.optionalQuantifier !== true) || (d.match.optionality === false || d.match.newBlockMarker === false) && d.match.optionalQuantifier !== true) && ((altTest.alternation === ba || altTest.alternation !== d.alternation) || (d.locator[altTest.alternation] !== ba && checkAlternationMatch(d.locator[altTest.alternation].toString().split(","), altArr))))) {
                    if (c !== true || (d.match.fn === null && !/[0-9a-bA-Z]/.test(d.match.def))) {
                        break
                    }
                }
            }
            return d
        }

        function getDecisionTaker(a) {
            var b = a.locator[a.alternation];
            if (typeof b == "string" && b.length > 0) {
                b = b.split(",")[0]
            }
            return b !== ba ? b.toString() : ""
        }

        function getLocator(a, b) {
            var c = (a.alternation != ba ? a.mloc[getDecisionTaker(a)] : a.locator).join("");
            while (c.length < b) c += "0";
            return c
        }

        function determineTestTemplate2(d, e, f) {
            d = d > 0 ? d - 1 : 0;
            var g = getTest(d),
                targetLocator = getLocator(g),
                tstLocator, closest, bestMatch;
            $.each(e, function(a, b) {
                tstLocator = getLocator(b, targetLocator.length);
                var c = Math.abs(tstLocator - targetLocator);
                if (closest === ba || (tstLocator !== "" && c < closest)) {
                    closest = c;
                    bestMatch = b
                }
            });
            return bestMatch
        }

        function getTestTemplate(a, b, c) {
            return getMaskSet().validPositions[a] || determineTestTemplate(a, getTests(a, b ? b.slice() : b, c))
        }

        function getTest(a, b) {
            if (getMaskSet().validPositions[a]) {
                return getMaskSet().validPositions[a]
            }
            return (b || getTests(a))[0]
        }

        function positionCanMatchDefinition(a, b) {
            var c = false,
                tests = getTests(a);
            for (var d = 0; d < tests.length; d++) {
                if (tests[d].match && tests[d].match.def === b) {
                    c = true;
                    break
                }
            }
            return c
        }

        function getTests(G, H, I) {
            var J = getMaskSet().maskToken,
                testPos = H ? I : 0,
                ndxInitializer = H ? H.slice() : [0],
                matches = [],
                insertStop = false,
                latestMatch, cacheDependency = H ? H.join("") : "";

            function resolveTestFromToken(A, B, C, D) {
                function handleMatch(j, k, m) {
                    function isFirstMatch(c, d) {
                        var e = $.inArray(c, d.matches) === 0;
                        if (!e) {
                            $.each(d.matches, function(a, b) {
                                if (b.isQuantifier === true) e = isFirstMatch(c, d.matches[a - 1]);
                                else if (b.isOptional === true) e = isFirstMatch(c, b);
                                else if (b.isAlternate === true) e = isFirstMatch(c, b);
                                if (e) return false
                            })
                        }
                        return e
                    }

                    function resolveNdxInitializer(d, e, f) {
                        var g, indexPos;
                        if (getMaskSet().tests[d] || getMaskSet().validPositions[d]) {
                            $.each(getMaskSet().tests[d] || [getMaskSet().validPositions[d]], function(a, b) {
                                if (b.mloc[e]) {
                                    g = b;
                                    return false
                                }
                                var c = f !== ba ? f : b.alternation,
                                    ndxPos = b.locator[c] !== ba ? b.locator[c].toString().indexOf(e) : -1;
                                if ((indexPos === ba || ndxPos < indexPos) && ndxPos !== -1) {
                                    g = b;
                                    indexPos = ndxPos
                                }
                            })
                        }
                        if (g) {
                            var h = g.locator[g.alternation];
                            var i = g.mloc[e] || g.mloc[h] || g.locator;
                            return i.slice((f !== ba ? f : g.alternation) + 1)
                        } else {
                            return f !== ba ? resolveNdxInitializer(d, e) : ba
                        }
                    }

                    function isSubsetOf(c, d) {
                        function expand(a) {
                            var b = [],
                                start, end;
                            for (var i = 0, l = a.length; i < l; i++) {
                                if (a.charAt(i) === "-") {
                                    end = a.charCodeAt(i + 1);
                                    while (++start < end) b.push(String.fromCharCode(start))
                                } else {
                                    start = a.charCodeAt(i);
                                    b.push(a.charAt(i))
                                }
                            }
                            return b.join("")
                        }
                        if (P.regex && c.match.fn !== null && d.match.fn !== null) {
                            return expand(d.match.def.replace(/[\[\]]/g, "")).indexOf(expand(c.match.def.replace(/[\[\]]/g, ""))) !== -1
                        }
                        return c.match.def === d.match.nativeDef
                    }

                    function staticCanMatchDefinition(a, b) {
                        return a.match.fn === null && b.match.fn !== null ? b.match.fn.test(a.match.def, getMaskSet(), G, false, P, false) : false
                    }

                    function setMergeLocators(a, b) {
                        if (b === ba || (a.alternation === b.alternation && a.locator[a.alternation].toString().indexOf(b.locator[b.alternation]) === -1)) {
                            a.mloc = a.mloc || {};
                            var c = a.locator[a.alternation];
                            if (c === ba) a.alternation = ba;
                            else {
                                if (typeof c === "string") c = c.split(",")[0];
                                if (a.mloc[c] === ba) a.mloc[c] = a.locator.slice();
                                if (b !== ba) {
                                    for (var d in b.mloc) {
                                        if (typeof d === "string") d = d.split(",")[0];
                                        if (a.mloc[d] === ba) a.mloc[d] = b.mloc[d]
                                    }
                                    a.locator[a.alternation] = Object.keys(a.mloc).join(",")
                                }
                                return true
                            }
                        }
                        return false
                    }
                    if (testPos > 5000) {
                        throw "Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. " + getMaskSet().mask;
                    }
                    if (testPos === G && j.matches === ba) {
                        matches.push({
                            "match": j,
                            "locator": k.reverse(),
                            "cd": cacheDependency,
                            "mloc": {}
                        });
                        return true
                    } else if (j.matches !== ba) {
                        if (j.isGroup && m !== j) {
                            j = handleMatch(A.matches[$.inArray(j, A.matches) + 1], k);
                            if (j) return true
                        } else if (j.isOptional) {
                            var n = j;
                            j = resolveTestFromToken(j, B, k, m);
                            if (j) {
                                latestMatch = matches[matches.length - 1].match;
                                if (m === ba && isFirstMatch(latestMatch, n)) {
                                    insertStop = true;
                                    testPos = G
                                } else return true
                            }
                        } else if (j.isAlternator) {
                            var o = j,
                                malternateMatches = [],
                                maltMatches, currentMatches = matches.slice(),
                                loopNdxCnt = k.length;
                            var p = B.length > 0 ? B.shift() : -1;
                            if (p === -1 || typeof p === "string") {
                                var q = testPos,
                                    ndxInitializerClone = B.slice(),
                                    altIndexArr = [],
                                    amndx;
                                if (typeof p == "string") {
                                    altIndexArr = p.split(",")
                                } else {
                                    for (amndx = 0; amndx < o.matches.length; amndx++) {
                                        altIndexArr.push(amndx.toString())
                                    }
                                }
                                if (getMaskSet().excludes[G]) {
                                    var r = altIndexArr.slice();
                                    for (var i = 0, el = getMaskSet().excludes[G].length; i < el; i++) {
                                        altIndexArr.splice(altIndexArr.indexOf(getMaskSet().excludes[G][i].toString()), 1)
                                    }
                                    if (altIndexArr.length === 0) {
                                        getMaskSet().excludes[G] = ba;
                                        altIndexArr = r
                                    }
                                }
                                if (P.keepStatic === true || (isFinite(parseInt(P.keepStatic)) && q >= P.keepStatic)) altIndexArr = altIndexArr.slice(0, 1);
                                for (var s = 0; s < altIndexArr.length; s++) {
                                    amndx = parseInt(altIndexArr[s]);
                                    matches = [];
                                    B = resolveNdxInitializer(testPos, amndx, loopNdxCnt) || ndxInitializerClone.slice();
                                    if (o.matches[amndx] && handleMatch(o.matches[amndx], [amndx].concat(k), m)) j = true;
                                    maltMatches = matches.slice();
                                    testPos = q;
                                    matches = [];
                                    for (var t = 0; t < maltMatches.length; t++) {
                                        var u = maltMatches[t],
                                            dropMatch = false;
                                        u.alternation = u.alternation || loopNdxCnt;
                                        setMergeLocators(u);
                                        for (var v = 0; v < malternateMatches.length; v++) {
                                            var w = malternateMatches[v];
                                            if (typeof p !== "string" || (u.alternation !== ba && $.inArray(u.locator[u.alternation].toString(), altIndexArr) !== -1)) {
                                                if (u.match.nativeDef === w.match.nativeDef) {
                                                    dropMatch = true;
                                                    setMergeLocators(w, u);
                                                    break
                                                } else if (isSubsetOf(u, w)) {
                                                    if (setMergeLocators(u, w)) {
                                                        dropMatch = true;
                                                        malternateMatches.splice(malternateMatches.indexOf(w), 0, u)
                                                    }
                                                    break
                                                } else if (isSubsetOf(w, u)) {
                                                    setMergeLocators(w, u);
                                                    break
                                                } else if (staticCanMatchDefinition(u, w)) {
                                                    if (setMergeLocators(u, w)) {
                                                        dropMatch = true;
                                                        malternateMatches.splice(malternateMatches.indexOf(w), 0, u)
                                                    }
                                                    break
                                                }
                                            }
                                        }
                                        if (!dropMatch) {
                                            malternateMatches.push(u)
                                        }
                                    }
                                }
                                matches = currentMatches.concat(malternateMatches);
                                testPos = G;
                                insertStop = matches.length > 0;
                                j = malternateMatches.length > 0;
                                B = ndxInitializerClone.slice()
                            } else j = handleMatch(o.matches[p] || A.matches[p], [p].concat(k), m);
                            if (j) return true
                        } else if (j.isQuantifier && m !== A.matches[$.inArray(j, A.matches) - 1]) {
                            var x = j;
                            for (var y = (B.length > 0) ? B.shift() : 0;
                                (y < (isNaN(x.quantifier.max) ? y + 1 : x.quantifier.max)) && testPos <= G; y++) {
                                var z = A.matches[$.inArray(x, A.matches) - 1];
                                j = handleMatch(z, [y].concat(k), z);
                                if (j) {
                                    latestMatch = matches[matches.length - 1].match;
                                    latestMatch.optionalQuantifier = y > (x.quantifier.min - 1);
                                    latestMatch.jit = y + z.matches.indexOf(latestMatch) >= x.quantifier.jit;
                                    if (isFirstMatch(latestMatch, z) && y > (x.quantifier.min - 1)) {
                                        insertStop = true;
                                        testPos = G;
                                        break
                                    }
                                    if (x.quantifier.jit !== ba && isNaN(x.quantifier.max) && latestMatch.optionalQuantifier && getMaskSet().validPositions[G - 1] === ba) {
                                        matches.pop();
                                        insertStop = true;
                                        testPos = G;
                                        cacheDependency = ba;
                                        break
                                    }
                                    return true
                                }
                            }
                        } else {
                            j = resolveTestFromToken(j, B, k, m);
                            if (j) return true
                        }
                    } else {
                        testPos++
                    }
                }
                for (var E = (B.length > 0 ? B.shift() : 0); E < A.matches.length; E++) {
                    if (A.matches[E].isQuantifier !== true) {
                        var F = handleMatch(A.matches[E], [E].concat(C), D);
                        if (F && testPos === G) {
                            return F
                        } else if (testPos > G) {
                            break
                        }
                    }
                }
            }

            function mergeLocators(c, d) {
                var e = [];
                if (!$.isArray(d)) d = [d];
                if (d.length > 0) {
                    if (d[0].alternation === ba) {
                        e = determineTestTemplate(c, d.slice()).locator.slice();
                        if (e.length === 0) e = d[0].locator.slice()
                    } else {
                        $.each(d, function(a, b) {
                            if (b.def !== "") {
                                if (e.length === 0) e = b.locator.slice();
                                else {
                                    for (var i = 0; i < e.length; i++) {
                                        if (b.locator[i] && e[i].toString().indexOf(b.locator[i]) === -1) {
                                            e[i] += "," + b.locator[i]
                                        }
                                    }
                                }
                            }
                        })
                    }
                }
                return e
            }
            if (G > -1) {
                if (H === ba) {
                    var K = G - 1,
                        test;
                    while ((test = getMaskSet().validPositions[K] || getMaskSet().tests[K]) === ba && K > -1) {
                        K--
                    }
                    if (test !== ba && K > -1) {
                        ndxInitializer = mergeLocators(K, test);
                        cacheDependency = ndxInitializer.join("");
                        testPos = K
                    }
                }
                if (getMaskSet().tests[G] && getMaskSet().tests[G][0].cd === cacheDependency) {
                    return getMaskSet().tests[G]
                }
                for (var L = ndxInitializer.shift(); L < J.length; L++) {
                    var M = resolveTestFromToken(J[L], ndxInitializer, [L]);
                    if ((M && testPos === G) || testPos > G) {
                        break
                    }
                }
            }
            if (matches.length === 0 || insertStop) {
                matches.push({
                    match: {
                        fn: null,
                        optionality: true,
                        casing: null,
                        def: "",
                        placeholder: ""
                    },
                    locator: [],
                    mloc: {},
                    cd: cacheDependency
                })
            }
            if (H !== ba && getMaskSet().tests[G]) {
                return $.extend(true, [], matches)
            }
            getMaskSet().tests[G] = $.extend(true, [], matches);
            return getMaskSet().tests[G]
        }

        function getBufferTemplate() {
            if (getMaskSet()._buffer === ba) {
                getMaskSet()._buffer = getMaskTemplate(false, 1);
                if (getMaskSet().buffer === ba) getMaskSet().buffer = getMaskSet()._buffer.slice()
            }
            return getMaskSet()._buffer
        }

        function getBuffer(a) {
            if (getMaskSet().buffer === ba || a === true) {
                getMaskSet().buffer = getMaskTemplate(true, getLastValidPosition(), true)
            }
            return getMaskSet().buffer
        }

        function refreshFromBuffer(a, b, c) {
            var i, p;
            if (a === true) {
                resetMaskSet();
                a = 0;
                b = c.length
            } else {
                for (i = a; i < b; i++) {
                    delete getMaskSet().validPositions[i]
                }
            }
            p = a;
            for (i = a; i < b; i++) {
                resetMaskSet(true);
                if (c[i] !== P.skipOptionalPartCharacter) {
                    var d = isValid(p, c[i], true, true);
                    if (d !== false) {
                        resetMaskSet(true);
                        p = d.caret !== ba ? d.caret : d.pos + 1
                    }
                }
            }
        }

        function casing(a, b, c) {
            switch (P.casing || b.casing) {
                case "upper":
                    a = a.toUpperCase();
                    break;
                case "lower":
                    a = a.toLowerCase();
                    break;
                case "title":
                    var d = getMaskSet().validPositions[c - 1];
                    if (c === 0 || d && d.input === String.fromCharCode(Inputmask.keyCode.SPACE)) {
                        a = a.toUpperCase()
                    } else {
                        a = a.toLowerCase()
                    }
                    break;
                default:
                    if ($.isFunction(P.casing)) {
                        var e = Array.prototype.slice.call(arguments);
                        e.push(getMaskSet().validPositions);
                        a = P.casing.apply(this, e)
                    }
            }
            return a
        }

        function checkAlternationMatch(a, b, c) {
            var d = P.greedy ? b : b.slice(0, 1),
                isMatch = false,
                naArr = c !== ba ? c.split(",") : [],
                naNdx;
            for (var i = 0; i < naArr.length; i++) {
                if ((naNdx = a.indexOf(naArr[i])) !== -1) {
                    a.splice(naNdx, 1)
                }
            }
            for (var e = 0; e < a.length; e++) {
                if ($.inArray(a[e], d) !== -1) {
                    isMatch = true;
                    break
                }
            }
            return isMatch
        }

        function alternate(a, c, b, d, e) {
            var f = $.extend(true, {}, getMaskSet().validPositions),
                lastAlt, alternation, isValidRslt = false,
                altPos, prevAltPos, i, validPos, decisionPos, lAltPos = e !== ba ? e : getLastValidPosition();
            if (lAltPos === -1 && e === ba) {
                lastAlt = 0;
                prevAltPos = getTest(lastAlt);
                alternation = prevAltPos.alternation
            } else {
                for (; lAltPos >= 0; lAltPos--) {
                    altPos = getMaskSet().validPositions[lAltPos];
                    if (altPos && altPos.alternation !== ba) {
                        if (prevAltPos && prevAltPos.locator[altPos.alternation] !== altPos.locator[altPos.alternation]) {
                            break
                        }
                        lastAlt = lAltPos;
                        alternation = getMaskSet().validPositions[lastAlt].alternation;
                        prevAltPos = altPos
                    }
                }
            }
            if (alternation !== ba) {
                decisionPos = parseInt(lastAlt);
                getMaskSet().excludes[decisionPos] = getMaskSet().excludes[decisionPos] || [];
                if (a !== true) {
                    getMaskSet().excludes[decisionPos].push(getDecisionTaker(prevAltPos))
                }
                var g = [],
                    staticInputsBeforePos = 0;
                for (i = decisionPos; i < getLastValidPosition(ba, true) + 1; i++) {
                    validPos = getMaskSet().validPositions[i];
                    if (validPos && validPos.generatedInput !== true && /[0-9a-bA-Z]/.test(validPos.input)) {
                        g.push(validPos.input)
                    } else if (i < a) staticInputsBeforePos++;
                    delete getMaskSet().validPositions[i]
                }
                while (getMaskSet().excludes[decisionPos] && getMaskSet().excludes[decisionPos].length < 10) {
                    var h = staticInputsBeforePos * -1,
                        validInputs = g.slice();
                    getMaskSet().tests[decisionPos] = ba;
                    resetMaskSet(true);
                    isValidRslt = true;
                    while (validInputs.length > 0) {
                        var j = validInputs.shift();
                        if (j !== P.skipOptionalPartCharacter) {
                            if (!(isValidRslt = isValid(getLastValidPosition(ba, true) + 1, j, false, d, true))) {
                                break
                            }
                        }
                    }
                    if (isValidRslt && c !== ba) {
                        var k = getLastValidPosition(a) + 1;
                        for (i = decisionPos; i < getLastValidPosition() + 1; i++) {
                            validPos = getMaskSet().validPositions[i];
                            if ((validPos === ba || validPos.match.fn == null) && i < (a + h)) {
                                h++
                            }
                        }
                        a = a + h;
                        isValidRslt = isValid(a > k ? k : a, c, b, d, true)
                    }
                    if (!isValidRslt) {
                        resetMaskSet();
                        prevAltPos = getTest(decisionPos);
                        getMaskSet().validPositions = $.extend(true, {}, f);
                        if (getMaskSet().excludes[decisionPos]) {
                            var l = getDecisionTaker(prevAltPos);
                            if (getMaskSet().excludes[decisionPos].indexOf(l) !== -1) {
                                isValidRslt = alternate(a, c, b, d, decisionPos - 1);
                                break
                            }
                            getMaskSet().excludes[decisionPos].push(l);
                            for (i = decisionPos; i < getLastValidPosition(ba, true) + 1; i++) delete getMaskSet().validPositions[i]
                        } else {
                            isValidRslt = alternate(a, c, b, d, decisionPos - 1);
                            break
                        }
                    } else break
                }
            }
            getMaskSet().excludes[decisionPos] = ba;
            return isValidRslt
        }

        function isValid(m, c, n, o, p, q) {
            function isSelection(a) {
                return isRTL ? (a.begin - a.end) > 1 || ((a.begin - a.end) === 1) : (a.end - a.begin) > 1 || ((a.end - a.begin) === 1)
            }
            n = n === true;
            var r = m;
            if (m.begin !== ba) {
                r = isRTL && !isSelection(m) ? m.end : m.begin
            }

            function _isValid(j, c, k) {
                var l = false;
                $.each(getTests(j), function(d, e) {
                    var f = e.match;
                    getBuffer(true);
                    l = f.fn != null ? f.fn.test(c, getMaskSet(), j, k, P, isSelection(m)) : (c === f.def || c === P.skipOptionalPartCharacter) && f.def !== "" ? {
                        c: getPlaceholder(j, f, true) || f.def,
                        pos: j
                    } : false;
                    if (l !== false) {
                        var g = l.c !== ba ? l.c : c;
                        g = (g === P.skipOptionalPartCharacter && f.fn === null) ? (getPlaceholder(j, f, true) || f.def) : g;
                        var h = j,
                            possibleModifiedBuffer = getBuffer();
                        if (l.remove !== ba) {
                            if (!$.isArray(l.remove)) l.remove = [l.remove];
                            $.each(l.remove.sort(function(a, b) {
                                return b - a
                            }), function(a, b) {
                                stripValidPositions({
                                    begin: b,
                                    end: b + 1
                                }, true)
                            })
                        }
                        if (l.insert !== ba) {
                            if (!$.isArray(l.insert)) l.insert = [l.insert];
                            $.each(l.insert.sort(function(a, b) {
                                return a - b
                            }), function(a, b) {
                                isValid(b.pos, b.c, true, o)
                            })
                        }
                        if (l.refreshFromBuffer) {
                            var i = l.refreshFromBuffer;
                            refreshFromBuffer(i === true ? i : i.start, i.end, possibleModifiedBuffer);
                            if (l.pos === ba && l.c === ba) {
                                l.pos = getLastValidPosition();
                                return false
                            }
                            h = l.pos !== ba ? l.pos : j;
                            if (h !== j) {
                                l = $.extend(l, isValid(h, g, true, o));
                                return false
                            }
                        } else if (l !== true && l.pos !== ba && l.pos !== j) {
                            h = l.pos;
                            refreshFromBuffer(j, h, getBuffer().slice());
                            if (h !== j) {
                                l = $.extend(l, isValid(h, g, true));
                                return false
                            }
                        }
                        if (l !== true && l.pos === ba && l.c === ba) {
                            return false
                        }
                        if (d > 0) {
                            resetMaskSet(true)
                        }
                        if (!setValidPosition(h, $.extend({}, e, {
                                "input": casing(g, f, h)
                            }), o, isSelection(m))) {
                            l = false
                        }
                        return false
                    }
                });
                return l
            }
            var s = true,
                positionsClone = $.extend(true, {}, getMaskSet().validPositions);
            if ($.isFunction(P.preValidation) && !n && o !== true && q !== true) {
                s = P.preValidation(getBuffer(), r, c, isSelection(m), P, getMaskSet())
            }
            if (s === true) {
                trackbackPositions(ba, r, true);
                if (isSelection(m)) {
                    handleRemove(ba, Inputmask.keyCode.DELETE, m, true, true);
                    r = getMaskSet().p
                }
                if (maxLength === ba || r < maxLength) {
                    s = _isValid(r, c, n);
                    if ((!n || o === true) && s === false && q !== true) {
                        var t = getMaskSet().validPositions[r];
                        if (t && t.match.fn === null && (t.match.def === c || c === P.skipOptionalPartCharacter)) {
                            s = {
                                "caret": seekNext(r)
                            }
                        } else if ((P.insertMode || getMaskSet().validPositions[seekNext(r)] === ba) && !isMask(r, true)) {
                            for (var u = r + 1, snPos = seekNext(r); u <= snPos; u++) {
                                s = _isValid(u, c, n);
                                if (s !== false) {
                                    s = trackbackPositions(r, s.pos !== ba ? s.pos : u) || s;
                                    r = u;
                                    break
                                }
                            }
                        }
                    }
                }
                if (s === false && (P.keepStatic !== null && P.keepStatic !== false) && !n && p !== true) {
                    s = alternate(r, c, n, o)
                }
                if (s === true) {
                    s = {
                        "pos": r
                    }
                }
            }
            if ($.isFunction(P.postValidation) && s !== false && !n && o !== true && q !== true) {
                var v = P.postValidation(getBuffer(true), s, P);
                if (v !== ba) {
                    if (v.refreshFromBuffer && v.buffer) {
                        var w = v.refreshFromBuffer;
                        refreshFromBuffer(w === true ? w : w.start, w.end, v.buffer)
                    }
                    s = v === true ? s : v
                }
            }
            if (s && s.pos === ba) {
                s.pos = r
            }
            if (s === false || q === true) {
                resetMaskSet(true);
                getMaskSet().validPositions = $.extend(true, {}, positionsClone)
            }
            return s
        }

        function trackbackPositions(d, e, f) {
            var g;
            if (d === ba) {
                for (d = e - 1; d > 0; d--) {
                    if (getMaskSet().validPositions[d]) break
                }
            }
            for (var h = d; h < e; h++) {
                if (getMaskSet().validPositions[h] === ba && !isMask(h, true)) {
                    var i = h == 0 ? getTest(h) : getMaskSet().validPositions[h - 1];
                    if (i) {
                        var j = getLocator(i),
                            tests = getTests(h).slice(),
                            tstLocator, closest = ba,
                            bestMatch = getTest(h);
                        if (tests[tests.length - 1].match.def === "") tests.pop();
                        $.each(tests, function(a, b) {
                            tstLocator = getLocator(b, j.length);
                            var c = Math.abs(tstLocator - j);
                            if ((closest === ba || c < closest) && b.match.fn === null && b.match.optionality !== true && b.match.optionalQuantifier !== true) {
                                closest = c;
                                bestMatch = b
                            }
                        });
                        bestMatch = $.extend({}, bestMatch, {
                            "input": getPlaceholder(h, bestMatch.match, true) || bestMatch.match.def
                        });
                        bestMatch.generatedInput = true;
                        setValidPosition(h, bestMatch, true);
                        if (f !== true) {
                            var k = getMaskSet().validPositions[e].input;
                            getMaskSet().validPositions[e] = ba;
                            g = isValid(e, k, true, true)
                        }
                    }
                }
            }
            return g
        }

        function setValidPosition(a, b, c, d) {
            if (a.begin === ba) a = {
                begin: a,
                end: a
            };
            if (d || (P.insertMode && getMaskSet().validPositions[a.begin] !== ba && c === ba)) {
                var e = $.extend(true, {}, getMaskSet().validPositions),
                    lvp = getLastValidPosition(ba, true),
                    i;
                for (i = a.begin; i <= lvp; i++) {
                    delete getMaskSet().validPositions[i]
                }
                if (b) getMaskSet().validPositions[a.begin] = $.extend(true, {}, b);
                else a.begin--;
                var f = true,
                    offset = a.end - a.begin,
                    j, vps = getMaskSet().validPositions,
                    needsValidation = false;
                for (i = (j = a.begin); i <= lvp; i++) {
                    var t = e[i + offset];
                    if (t !== ba) {
                        var g = j;
                        while (getTest(g).match.def !== "" && ((t.match.fn === null && vps[i] && (vps[i].match.optionalQuantifier === true || vps[i].match.optionality === true)) || t.match.fn != null)) {
                            g++;
                            if (needsValidation === false && e[g] && e[g].match.def === t.match.def) {
                                getMaskSet().validPositions[g] = $.extend(true, {}, e[g]);
                                getMaskSet().validPositions[g].input = t.input;
                                trackbackPositions(ba, g, true);
                                j = g;
                                f = true
                            } else if (positionCanMatchDefinition(g, t.match.def)) {
                                var h = isValid(g, t.input, true, true);
                                f = h !== false;
                                j = (h.caret || h.insert) ? getLastValidPosition() : g;
                                needsValidation = true
                            } else {
                                f = t.generatedInput === true;
                                if (!f && getTest(g).match.def === "") break
                            }
                            if (f) break
                        }
                    }
                    if (!f) break
                }
                if (!f) {
                    getMaskSet().validPositions = $.extend(true, {}, e);
                    resetMaskSet(true);
                    return false
                }
            } else {
                getMaskSet().validPositions[a.begin] = $.extend(true, {}, b)
            }
            resetMaskSet(true);
            return true
        }

        function isMask(a, b) {
            var c = getTestTemplate(a).match;
            if (c.def === "") c = getTest(a).match;
            if (c.fn != null) {
                return c.fn
            }
            if (b !== true && a > -1) {
                var d = getTests(a);
                return d.length > 1 + (d[d.length - 1].match.def === "" ? 1 : 0)
            }
            return false
        }

        function seekNext(a, b) {
            var c = a + 1;
            while (getTest(c).match.def !== "" && ((b === true && (getTest(c).match.newBlockMarker !== true || !isMask(c))) || (b !== true && !isMask(c)))) {
                c++
            }
            return c
        }

        function seekPrevious(a, b) {
            var c = a,
                tests;
            if (c <= 0) return 0;
            while (--c > 0 && ((b === true && getTest(c).match.newBlockMarker !== true) || (b !== true && !isMask(c) && (tests = getTests(c), tests.length < 2 || (tests.length === 2 && tests[1].match.def === ""))))) {}
            return c
        }

        function getBufferElement(a) {
            return getMaskSet().validPositions[a] === ba ? getPlaceholder(a) : getMaskSet().validPositions[a].input
        }

        function writeBuffer(a, b, c, d, e) {
            if (d && $.isFunction(P.onBeforeWrite)) {
                var f = P.onBeforeWrite.call(Q, d, b, c, P);
                if (f) {
                    if (f.refreshFromBuffer) {
                        var g = f.refreshFromBuffer;
                        refreshFromBuffer(g === true ? g : g.start, g.end, f.buffer || b);
                        b = getBuffer(true)
                    }
                    if (c !== ba) c = f.caret !== ba ? f.caret : c
                }
            }
            if (a !== ba) {
                a.inputmask._valueSet(b.join(""));
                if (c !== ba && (d === ba || d.type !== "blur")) {
                    caret(a, c)
                } else renderColorMask(a, c, b.length === 0);
                if (e === true) {
                    skipInputEvent = true;
                    $(a).trigger("input")
                }
            }
        }

        function getPlaceholder(a, b, c) {
            b = b || getTest(a).match;
            if (b.placeholder !== ba || c === true) {
                return $.isFunction(b.placeholder) ? b.placeholder(P) : b.placeholder
            } else if (b.fn === null) {
                if (a > -1 && getMaskSet().validPositions[a] === ba) {
                    var d = getTests(a),
                        staticAlternations = [],
                        prevTest;
                    if (d.length > 1 + (d[d.length - 1].match.def === "" ? 1 : 0)) {
                        for (var i = 0; i < d.length; i++) {
                            if (d[i].match.optionality !== true && d[i].match.optionalQuantifier !== true && (d[i].match.fn === null || (prevTest === ba || d[i].match.fn.test(prevTest.match.def, getMaskSet(), a, true, P) !== false))) {
                                staticAlternations.push(d[i]);
                                if (d[i].match.fn === null) prevTest = d[i];
                                if (staticAlternations.length > 1) {
                                    if (/[0-9a-bA-Z]/.test(staticAlternations[0].match.def)) {
                                        return P.placeholder.charAt(a % P.placeholder.length)
                                    }
                                }
                            }
                        }
                    }
                }
                return b.def
            }
            return P.placeholder.charAt(a % P.placeholder.length)
        }
        var R = {
            on: function(f, g, h) {
                var i = function(e) {
                    var a = this;
                    if (a.inputmask === ba && this.nodeName !== "FORM") {
                        var b = $.data(a, "_inputmask_opts");
                        if (b)(new Inputmask(b)).mask(a);
                        else R.off(a)
                    } else if (e.type !== "setvalue" && this.nodeName !== "FORM" && (a.disabled || (a.readOnly && !(e.type === "keydown" && (e.ctrlKey && e.keyCode === 67) || (P.tabThrough === false && e.keyCode === Inputmask.keyCode.TAB))))) {
                        e.preventDefault()
                    } else {
                        switch (e.type) {
                            case "input":
                                if (skipInputEvent === true) {
                                    skipInputEvent = false;
                                    return e.preventDefault()
                                }
                                if (mobile) {
                                    trackCaret = true
                                }
                                break;
                            case "keydown":
                                skipKeyPressEvent = false;
                                skipInputEvent = false;
                                break;
                            case "keypress":
                                if (skipKeyPressEvent === true) {
                                    return e.preventDefault()
                                }
                                skipKeyPressEvent = true;
                                break;
                            case "click":
                                if (iemobile || iphone) {
                                    var c = arguments;
                                    setTimeout(function() {
                                        h.apply(a, c)
                                    }, 0);
                                    return false
                                }
                                break
                        }
                        var d = h.apply(a, arguments);
                        if (trackCaret) {
                            trackCaret = false;
                            setTimeout(function() {
                                caret(a, a.inputmask.caretPos, ba, true)
                            })
                        }
                        if (d === false) {
                            e.preventDefault();
                            e.stopPropagation()
                        }
                        return d
                    }
                };
                f.inputmask.events[g] = f.inputmask.events[g] || [];
                f.inputmask.events[g].push(i);
                if ($.inArray(g, ["submit", "reset"]) !== -1) {
                    if (f.form !== null) $(f.form).on(g, i)
                } else {
                    $(f).on(g, i)
                }
            },
            off: function(d, e) {
                if (d.inputmask && d.inputmask.events) {
                    var f;
                    if (e) {
                        f = [];
                        f[e] = d.inputmask.events[e]
                    } else {
                        f = d.inputmask.events
                    }
                    $.each(f, function(a, b) {
                        while (b.length > 0) {
                            var c = b.pop();
                            if ($.inArray(a, ["submit", "reset"]) !== -1) {
                                if (d.form !== null) $(d.form).off(a, c)
                            } else {
                                $(d).off(a, c)
                            }
                        }
                        delete d.inputmask.events[a]
                    })
                }
            }
        };
        var S = {
            keydownEvent: function(e) {
                var b = this,
                    $input = $(b),
                    k = e.keyCode,
                    pos = caret(b);
                if (k === Inputmask.keyCode.BACKSPACE || k === Inputmask.keyCode.DELETE || (iphone && k === Inputmask.keyCode.BACKSPACE_SAFARI) || (e.ctrlKey && k === Inputmask.keyCode.X && !isInputEventSupported("cut"))) {
                    e.preventDefault();
                    handleRemove(b, k, pos);
                    writeBuffer(b, getBuffer(true), getMaskSet().p, e, b.inputmask._valueGet() !== getBuffer().join(""));
                    if (b.inputmask._valueGet() === getBufferTemplate().join("")) {
                        $input.trigger("cleared")
                    } else if (isComplete(getBuffer()) === true) {
                        $input.trigger("complete")
                    }
                } else if (k === Inputmask.keyCode.END || k === Inputmask.keyCode.PAGE_DOWN) {
                    e.preventDefault();
                    var c = seekNext(getLastValidPosition());
                    if (!P.insertMode && c === getMaskSet().maskLength && !e.shiftKey) c--;
                    caret(b, e.shiftKey ? pos.begin : c, c, true)
                } else if ((k === Inputmask.keyCode.HOME && !e.shiftKey) || k === Inputmask.keyCode.PAGE_UP) {
                    e.preventDefault();
                    caret(b, 0, e.shiftKey ? pos.begin : 0, true)
                } else if (((P.undoOnEscape && k === Inputmask.keyCode.ESCAPE) || (k === 90 && e.ctrlKey)) && e.altKey !== true) {
                    checkVal(b, true, false, undoValue.split(""));
                    $input.trigger("click")
                } else if (k === Inputmask.keyCode.INSERT && !(e.shiftKey || e.ctrlKey)) {
                    P.insertMode = !P.insertMode;
                    caret(b, !P.insertMode && pos.begin === getMaskSet().maskLength ? pos.begin - 1 : pos.begin)
                } else if (P.tabThrough === true && k === Inputmask.keyCode.TAB) {
                    if (e.shiftKey === true) {
                        if (getTest(pos.begin).match.fn === null) {
                            pos.begin = seekNext(pos.begin)
                        }
                        pos.end = seekPrevious(pos.begin, true);
                        pos.begin = seekPrevious(pos.end, true)
                    } else {
                        pos.begin = seekNext(pos.begin, true);
                        pos.end = seekNext(pos.begin, true);
                        if (pos.end < getMaskSet().maskLength) pos.end--
                    }
                    if (pos.begin < getMaskSet().maskLength) {
                        e.preventDefault();
                        caret(b, pos.begin, pos.end)
                    }
                } else if (!e.shiftKey) {
                    if (P.insertMode === false) {
                        if (k === Inputmask.keyCode.RIGHT) {
                            setTimeout(function() {
                                var a = caret(b);
                                caret(b, a.begin)
                            }, 0)
                        } else if (k === Inputmask.keyCode.LEFT) {
                            setTimeout(function() {
                                var a = caret(b);
                                caret(b, isRTL ? a.begin + 1 : a.begin - 1)
                            }, 0)
                        }
                    }
                }
                P.onKeyDown.call(this, e, getBuffer(), caret(b).begin, P);
                ignorable = $.inArray(k, P.ignorables) !== -1
            },
            keypressEvent: function(e, a, b, d, f) {
                var g = this,
                    $input = $(g),
                    k = e.which || e.charCode || e.keyCode;
                if (a !== true && (!(e.ctrlKey && e.altKey) && (e.ctrlKey || e.metaKey || ignorable))) {
                    if (k === Inputmask.keyCode.ENTER && undoValue !== getBuffer().join("")) {
                        undoValue = getBuffer().join("");
                        setTimeout(function() {
                            $input.trigger("change")
                        }, 0)
                    }
                    return true
                } else {
                    if (k) {
                        if (k === 46 && e.shiftKey === false && P.radixPoint !== "") k = P.radixPoint.charCodeAt(0);
                        var h = a ? {
                                begin: f,
                                end: f
                            } : caret(g),
                            forwardPosition, c = String.fromCharCode(k),
                            offset = 0;
                        if (P._radixDance && P.numericInput) {
                            var i = getBuffer().indexOf(P.radixPoint.charAt(0)) + 1;
                            if (h.begin <= i) {
                                if (k === P.radixPoint.charCodeAt(0)) offset = 1;
                                h.begin -= 1;
                                h.end -= 1
                            }
                        }
                        getMaskSet().writeOutBuffer = true;
                        var j = isValid(h, c, d);
                        if (j !== false) {
                            resetMaskSet(true);
                            forwardPosition = j.caret !== ba ? j.caret : seekNext(j.pos.begin ? j.pos.begin : j.pos);
                            getMaskSet().p = forwardPosition
                        }
                        forwardPosition = ((P.numericInput && j.caret === ba) ? seekPrevious(forwardPosition) : forwardPosition) + offset;
                        if (b !== false) {
                            setTimeout(function() {
                                P.onKeyValidation.call(g, k, j, P)
                            }, 0);
                            if (getMaskSet().writeOutBuffer && j !== false) {
                                var l = getBuffer();
                                writeBuffer(g, l, forwardPosition, e, a !== true);
                                if (a !== true) {
                                    setTimeout(function() {
                                        if (isComplete(l) === true) $input.trigger("complete")
                                    }, 0)
                                }
                            }
                        }
                        e.preventDefault();
                        if (a) {
                            if (j !== false) j.forwardPosition = forwardPosition;
                            return j
                        }
                    }
                }
            },
            pasteEvent: function(e) {
                var a = this,
                    ev = e.originalEvent || e,
                    $input = $(a),
                    inputValue = a.inputmask._valueGet(true),
                    caretPos = caret(a),
                    tempValue;
                if (isRTL) {
                    tempValue = caretPos.end;
                    caretPos.end = caretPos.begin;
                    caretPos.begin = tempValue
                }
                var b = inputValue.substr(0, caretPos.begin),
                    valueAfterCaret = inputValue.substr(caretPos.end, inputValue.length);
                if (b === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(0, caretPos.begin).join("")) b = "";
                if (valueAfterCaret === (isRTL ? getBufferTemplate().reverse() : getBufferTemplate()).slice(caretPos.end).join("")) valueAfterCaret = "";
                if (isRTL) {
                    tempValue = b;
                    b = valueAfterCaret;
                    valueAfterCaret = tempValue
                }
                if (Y.clipboardData && Y.clipboardData.getData) {
                    inputValue = b + Y.clipboardData.getData("Text") + valueAfterCaret
                } else if (ev.clipboardData && ev.clipboardData.getData) {
                    inputValue = b + ev.clipboardData.getData("text/plain") + valueAfterCaret
                } else return true;
                var c = inputValue;
                if ($.isFunction(P.onBeforePaste)) {
                    c = P.onBeforePaste.call(Q, inputValue, P);
                    if (c === false) {
                        return e.preventDefault()
                    }
                    if (!c) {
                        c = inputValue
                    }
                }
                checkVal(a, false, false, isRTL ? c.split("").reverse() : c.toString().split(""));
                writeBuffer(a, getBuffer(), seekNext(getLastValidPosition()), e, undoValue !== getBuffer().join(""));
                if (isComplete(getBuffer()) === true) {
                    $input.trigger("complete")
                }
                return e.preventDefault()
            },
            inputFallBackEvent: function(e) {
                function radixPointHandler(a, b, c) {
                    if (b.charAt(c.begin - 1) === "." && P.radixPoint !== "") {
                        b = b.split("");
                        b[c.begin - 1] = P.radixPoint.charAt(0);
                        b = b.join("")
                    }
                    return b
                }

                function ieMobileHandler(a, b, c) {
                    if (iemobile) {
                        var d = b.replace(getBuffer().join(""), "");
                        if (d.length === 1) {
                            var e = b.split("");
                            e.splice(c.begin, 0, d);
                            b = e.join("")
                        }
                    }
                    return b
                }
                var f = this,
                    inputValue = f.inputmask._valueGet();
                if (getBuffer().join("") !== inputValue) {
                    var g = caret(f);
                    inputValue = radixPointHandler(f, inputValue, g);
                    inputValue = ieMobileHandler(f, inputValue, g);
                    if (getBuffer().join("") !== inputValue) {
                        var h = getBuffer().join(""),
                            offset = (!P.numericInput && inputValue.length > h.length) ? -1 : 0,
                            frontPart = inputValue.substr(0, g.begin),
                            backPart = inputValue.substr(g.begin),
                            frontBufferPart = h.substr(0, g.begin + offset),
                            backBufferPart = h.substr(g.begin + offset);
                        var j = g,
                            entries = "",
                            isEntry = false;
                        if (frontPart !== frontBufferPart) {
                            var k = (isEntry = frontPart.length >= frontBufferPart.length) ? frontPart.length : frontBufferPart.length;
                            for (var i = 0; frontPart.charAt(i) === frontBufferPart.charAt(i) && i < k; i++) {}
                            if (isEntry) {
                                if (offset === 0) j.begin = i;
                                entries += frontPart.slice(i, j.end)
                            }
                        }
                        if (backPart !== backBufferPart) {
                            if (backPart.length > backBufferPart.length) {
                                entries += backPart.slice(0, 1)
                            } else {
                                if (backPart.length < backBufferPart.length) {
                                    j.end += backBufferPart.length - backPart.length;
                                    if (!isEntry && P.radixPoint !== "" && backPart === "" && frontPart.charAt(j.begin + offset - 1) === P.radixPoint) {
                                        j.begin--;
                                        entries = P.radixPoint
                                    }
                                }
                            }
                        }
                        writeBuffer(f, getBuffer(), {
                            "begin": j.begin + offset,
                            "end": j.end + offset
                        });
                        if (entries.length > 0) {
                            $.each(entries.split(""), function(a, b) {
                                var c = new $.Event("keypress");
                                c.which = b.charCodeAt(0);
                                ignorable = false;
                                S.keypressEvent.call(f, c)
                            })
                        } else {
                            if (j.begin === j.end - 1) {
                                j.begin = seekPrevious(j.begin + 1);
                                if (j.begin === j.end - 1) {
                                    caret(f, j.begin)
                                } else {
                                    caret(f, j.begin, j.end)
                                }
                            }
                            var l = new $.Event("keydown");
                            l.keyCode = P.numericInput ? Inputmask.keyCode.BACKSPACE : Inputmask.keyCode.DELETE;
                            S.keydownEvent.call(f, l);
                            if (P.insertMode === false) {
                                caret(f, caret(f).begin - 1)
                            }
                        }
                        e.preventDefault()
                    }
                }
            },
            setValueEvent: function(e) {
                this.inputmask.refreshValue = false;
                var a = this,
                    value = (e && e.detail) ? e.detail[0] : arguments[1],
                    value = value || a.inputmask._valueGet(true);
                if ($.isFunction(P.onBeforeMask)) value = P.onBeforeMask.call(Q, value, P) || value;
                value = value.split("");
                checkVal(a, true, false, isRTL ? value.reverse() : value);
                undoValue = getBuffer().join("");
                if ((P.clearMaskOnLostFocus || P.clearIncomplete) && a.inputmask._valueGet() === getBufferTemplate().join("")) {
                    a.inputmask._valueSet("")
                }
            },
            focusEvent: function(e) {
                var a = this,
                    nptValue = a.inputmask._valueGet();
                if (P.showMaskOnFocus && (!P.showMaskOnHover || (P.showMaskOnHover && nptValue === ""))) {
                    if (a.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(a, getBuffer(), seekNext(getLastValidPosition()))
                    } else if (mouseEnter === false) {
                        caret(a, seekNext(getLastValidPosition()))
                    }
                }
                if (P.positionCaretOnTab === true && mouseEnter === false) {
                    S.clickEvent.apply(a, [e, true])
                }
                undoValue = getBuffer().join("")
            },
            mouseleaveEvent: function(e) {
                var a = this;
                mouseEnter = false;
                if (P.clearMaskOnLostFocus && Z.activeElement !== a) {
                    var b = getBuffer().slice(),
                        nptValue = a.inputmask._valueGet();
                    if (nptValue !== a.getAttribute("placeholder") && nptValue !== "") {
                        if (getLastValidPosition() === -1 && nptValue === getBufferTemplate().join("")) {
                            b = []
                        } else {
                            clearOptionalTail(b)
                        }
                        writeBuffer(a, b)
                    }
                }
            },
            clickEvent: function(e, f) {
                function doRadixFocus(a) {
                    if (P.radixPoint !== "") {
                        var b = getMaskSet().validPositions;
                        if (b[a] === ba || (b[a].input === getPlaceholder(a))) {
                            if (a < seekNext(-1)) return true;
                            var c = $.inArray(P.radixPoint, getBuffer());
                            if (c !== -1) {
                                for (var d in b) {
                                    if (c < d && b[d].input !== getPlaceholder(d)) {
                                        return false
                                    }
                                }
                                return true
                            }
                        }
                    }
                    return false
                }
                var g = this;
                setTimeout(function() {
                    if (Z.activeElement === g) {
                        var a = caret(g);
                        if (f) {
                            if (isRTL) {
                                a.end = a.begin
                            } else {
                                a.begin = a.end
                            }
                        }
                        if (a.begin === a.end) {
                            switch (P.positionCaretOnClick) {
                                case "none":
                                    break;
                                case "select":
                                    caret(g, 0, getBuffer().length);
                                    break;
                                case "radixFocus":
                                    if (doRadixFocus(a.begin)) {
                                        var b = getBuffer().join("").indexOf(P.radixPoint);
                                        caret(g, P.numericInput ? seekNext(b) : b);
                                        break
                                    }
                                default:
                                    var c = a.begin,
                                        lvclickPosition = getLastValidPosition(c, true),
                                        lastPosition = seekNext(lvclickPosition);
                                    if (c < lastPosition) {
                                        caret(g, !isMask(c, true) && !isMask(c - 1, true) ? seekNext(c) : c)
                                    } else {
                                        var d = getMaskSet().validPositions[lvclickPosition],
                                            tt = getTestTemplate(lastPosition, d ? d.match.locator : ba, d),
                                            placeholder = getPlaceholder(lastPosition, tt.match);
                                        if ((placeholder !== "" && getBuffer()[lastPosition] !== placeholder && tt.match.optionalQuantifier !== true && tt.match.newBlockMarker !== true) || (!isMask(lastPosition, true) && tt.match.def === placeholder)) {
                                            var e = seekNext(lastPosition);
                                            if (c >= e || c === lastPosition) {
                                                lastPosition = e
                                            }
                                        }
                                        caret(g, lastPosition)
                                    }
                                    break
                            }
                        }
                    }
                }, 0)
            },
            dblclickEvent: function(e) {
                var a = this;
                setTimeout(function() {
                    caret(a, 0, seekNext(getLastValidPosition()))
                }, 0)
            },
            cutEvent: function(e) {
                var a = this,
                    $input = $(a),
                    pos = caret(a),
                    ev = e.originalEvent || e;
                var b = Y.clipboardData || ev.clipboardData,
                    clipData = isRTL ? getBuffer().slice(pos.end, pos.begin) : getBuffer().slice(pos.begin, pos.end);
                b.setData("text", isRTL ? clipData.reverse().join("") : clipData.join(""));
                if (Z.execCommand) Z.execCommand("copy");
                handleRemove(a, Inputmask.keyCode.DELETE, pos);
                writeBuffer(a, getBuffer(), getMaskSet().p, e, undoValue !== getBuffer().join(""));
                if (a.inputmask._valueGet() === getBufferTemplate().join("")) {
                    $input.trigger("cleared")
                }
            },
            blurEvent: function(e) {
                var a = $(this),
                    input = this;
                if (input.inputmask) {
                    var b = input.inputmask._valueGet(),
                        U = getBuffer().slice();
                    if (b !== "" || colorMask !== ba) {
                        if (P.clearMaskOnLostFocus) {
                            if (getLastValidPosition() === -1 && b === getBufferTemplate().join("")) {
                                U = []
                            } else {
                                clearOptionalTail(U)
                            }
                        }
                        if (isComplete(U) === false) {
                            setTimeout(function() {
                                a.trigger("incomplete")
                            }, 0);
                            if (P.clearIncomplete) {
                                resetMaskSet();
                                if (P.clearMaskOnLostFocus) {
                                    U = []
                                } else {
                                    U = getBufferTemplate().slice()
                                }
                            }
                        }
                        writeBuffer(input, U, ba, e)
                    }
                    if (undoValue !== getBuffer().join("")) {
                        undoValue = U.join("");
                        a.trigger("change")
                    }
                }
            },
            mouseenterEvent: function(e) {
                var a = this;
                mouseEnter = true;
                if (Z.activeElement !== a && P.showMaskOnHover) {
                    if (a.inputmask._valueGet() !== getBuffer().join("")) {
                        writeBuffer(a, getBuffer())
                    }
                }
            },
            submitEvent: function(e) {
                if (undoValue !== getBuffer().join("")) {
                    $el.trigger("change")
                }
                if (P.clearMaskOnLostFocus && getLastValidPosition() === -1 && el.inputmask._valueGet && el.inputmask._valueGet() === getBufferTemplate().join("")) {
                    el.inputmask._valueSet("")
                }
                if (P.removeMaskOnSubmit) {
                    el.inputmask._valueSet(el.inputmask.unmaskedvalue(), true);
                    setTimeout(function() {
                        writeBuffer(el, getBuffer())
                    }, 0)
                }
            },
            resetEvent: function(e) {
                el.inputmask.refreshValue = true;
                setTimeout(function() {
                    $el.trigger("setvalue")
                }, 0)
            }
        };

        function checkVal(f, g, h, i, j) {
            var k = i.slice(),
                charCodes = "",
                initialNdx = -1,
                result = ba;

            function isTemplateMatch(a, b) {
                var c = getMaskTemplate(true, 0, false).slice(a, seekNext(a)).join("").indexOf(b);
                return c !== -1 && !isMask(a) && (getTest(a).match.nativeDef === b.charAt(0) || (getTest(a).match.nativeDef === " " && getTest(a + 1).match.nativeDef === b.charAt(0)))
            }
            resetMaskSet();
            if (!h && P.autoUnmask !== true) {
                var l = getBufferTemplate().slice(0, seekNext(-1)).join(""),
                    matches = k.join("").match(new RegExp("^" + Inputmask.escapeRegex(l), "g"));
                if (matches && matches.length > 0) {
                    k.splice(0, matches.length * l.length);
                    initialNdx = seekNext(initialNdx)
                }
            } else {
                initialNdx = seekNext(initialNdx)
            }
            if (initialNdx === -1) {
                getMaskSet().p = seekNext(initialNdx);
                initialNdx = 0
            } else getMaskSet().p = initialNdx;
            $.each(k, function(a, b) {
                if (b !== ba) {
                    if (getMaskSet().validPositions[a] === ba && k[a] === getPlaceholder(a) && isMask(a, true) && isValid(a, k[a], true, ba, ba, true) === false) {
                        getMaskSet().p++
                    } else {
                        var c = new $.Event("_checkval");
                        c.which = b.charCodeAt(0);
                        charCodes += b;
                        var d = getLastValidPosition(ba, true),
                            prevTest = getTest(d),
                            nextTest = getTestTemplate(d + 1, prevTest ? prevTest.locator.slice() : ba, d);
                        if (!isTemplateMatch(initialNdx, charCodes) || h || P.autoUnmask) {
                            var e = h ? a : (nextTest.match.fn == null && nextTest.match.optionality && (d + 1) < getMaskSet().p ? d + 1 : getMaskSet().p);
                            result = S.keypressEvent.call(f, c, true, false, h, e);
                            if (result) {
                                initialNdx = e + 1;
                                charCodes = ""
                            }
                        } else {
                            result = S.keypressEvent.call(f, c, true, false, true, d + 1)
                        }
                        writeBuffer(ba, getBuffer(), result.forwardPosition, c, false)
                    }
                }
            });
            if (g) writeBuffer(f, getBuffer(), result ? result.forwardPosition : ba, j || new $.Event("checkval"), j && j.type === "input")
        }

        function unmaskedvalue(a) {
            if (a) {
                if (a.inputmask === ba) {
                    return a.value
                }
                if (a.inputmask && a.inputmask.refreshValue) {
                    S.setValueEvent.call(a)
                }
            }
            var b = [],
                vps = getMaskSet().validPositions;
            for (var c in vps) {
                if (vps[c].match && vps[c].match.fn != null) {
                    b.push(vps[c].input)
                }
            }
            var d = b.length === 0 ? "" : (isRTL ? b.reverse() : b).join("");
            if ($.isFunction(P.onUnMask)) {
                var e = (isRTL ? getBuffer().slice().reverse() : getBuffer()).join("");
                d = P.onUnMask.call(Q, e, d, P)
            }
            return d
        }

        function caret(b, c, d, e) {
            function translatePosition(a) {
                if (e !== true && isRTL && typeof a === "number" && (!P.greedy || P.placeholder !== "")) {
                    a = b.inputmask._valueGet().length - a
                }
                return a
            }
            var f;
            if (c !== ba) {
                if ($.isArray(c)) {
                    d = isRTL ? c[0] : c[1];
                    c = isRTL ? c[1] : c[0]
                }
                if (c.begin !== ba) {
                    d = isRTL ? c.begin : c.end;
                    c = isRTL ? c.end : c.begin
                }
                if (typeof c === "number") {
                    c = translatePosition(c);
                    d = translatePosition(d);
                    d = (typeof d == "number") ? d : c;
                    var g = parseInt(((b.ownerDocument.defaultView || Y).getComputedStyle ? (b.ownerDocument.defaultView || Y).getComputedStyle(b, null) : b.currentStyle).fontSize) * d;
                    b.scrollLeft = g > b.scrollWidth ? g : 0;
                    if (!iphone && P.insertMode === false && c === d) d++;
                    b.inputmask.caretPos = {
                        begin: c,
                        end: d
                    };
                    if (b.setSelectionRange) {
                        b.selectionStart = c;
                        b.selectionEnd = d
                    } else if (Y.getSelection) {
                        f = Z.createRange();
                        if (b.firstChild === ba || b.firstChild === null) {
                            var h = Z.createTextNode("");
                            b.appendChild(h)
                        }
                        f.setStart(b.firstChild, c < b.inputmask._valueGet().length ? c : b.inputmask._valueGet().length);
                        f.setEnd(b.firstChild, d < b.inputmask._valueGet().length ? d : b.inputmask._valueGet().length);
                        f.collapse(true);
                        var i = Y.getSelection();
                        i.removeAllRanges();
                        i.addRange(f)
                    } else if (b.createTextRange) {
                        f = b.createTextRange();
                        f.collapse(true);
                        f.moveEnd("character", d);
                        f.moveStart("character", c);
                        f.select()
                    }
                    renderColorMask(b, {
                        begin: c,
                        end: d
                    })
                }
            } else {
                if (b.setSelectionRange) {
                    c = b.selectionStart;
                    d = b.selectionEnd
                } else if (Y.getSelection) {
                    f = Y.getSelection().getRangeAt(0);
                    if (f.commonAncestorContainer.parentNode === b || f.commonAncestorContainer === b) {
                        c = f.startOffset;
                        d = f.endOffset
                    }
                } else if (Z.selection && Z.selection.createRange) {
                    f = Z.selection.createRange();
                    c = 0 - f.duplicate().moveStart("character", -b.inputmask._valueGet().length);
                    d = c + f.text.length
                }
                return {
                    "begin": translatePosition(c),
                    "end": translatePosition(d)
                }
            }
        }

        function determineLastRequiredPosition(a) {
            var b = getBuffer(),
                bl = b.length,
                pos, lvp = getLastValidPosition(),
                positions = {},
                lvTest = getMaskSet().validPositions[lvp],
                ndxIntlzr = lvTest !== ba ? lvTest.locator.slice() : ba,
                testPos;
            for (pos = lvp + 1; pos < b.length; pos++) {
                testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                ndxIntlzr = testPos.locator.slice();
                positions[pos] = $.extend(true, {}, testPos)
            }
            var c = lvTest && lvTest.alternation !== ba ? lvTest.locator[lvTest.alternation] : ba;
            for (pos = bl - 1; pos > lvp; pos--) {
                testPos = positions[pos];
                if ((testPos.match.optionality || (testPos.match.optionalQuantifier && testPos.match.newBlockMarker) || (c && ((c !== positions[pos].locator[lvTest.alternation] && testPos.match.fn != null) || (testPos.match.fn === null && testPos.locator[lvTest.alternation] && checkAlternationMatch(testPos.locator[lvTest.alternation].toString().split(","), c.toString().split(",")) && getTests(pos)[0].def !== "")))) && b[pos] === getPlaceholder(pos, testPos.match)) {
                    bl--
                } else break
            }
            return a ? {
                "l": bl,
                "def": positions[bl] ? positions[bl].match : ba
            } : bl
        }

        function clearOptionalTail(a) {
            var b = determineLastRequiredPosition(),
                validPos, bl = a.length;
            var c = getMaskSet().validPositions[getLastValidPosition()];
            while (b < bl && !isMask(b, true) && (validPos = (c !== ba ? getTestTemplate(b, c.locator.slice(""), c) : getTest(b))) && validPos.match.optionality !== true && ((validPos.match.optionalQuantifier !== true && validPos.match.newBlockMarker !== true) || (b + 1 === bl && (c !== ba ? getTestTemplate(b + 1, c.locator.slice(""), c) : getTest(b + 1)).match.def === ""))) {
                b++
            }
            while ((validPos = getMaskSet().validPositions[b - 1]) && validPos && validPos.match.optionality && validPos.input === P.skipOptionalPartCharacter) {
                b--
            }
            a.splice(b);
            return a
        }

        function isComplete(a) {
            if ($.isFunction(P.isComplete)) return P.isComplete(a, P);
            if (P.repeat === "*") return ba;
            var b = false,
                lrp = determineLastRequiredPosition(true),
                aml = seekPrevious(lrp.l);
            if (lrp.def === ba || lrp.def.newBlockMarker || lrp.def.optionality || lrp.def.optionalQuantifier) {
                b = true;
                for (var i = 0; i <= aml; i++) {
                    var c = getTestTemplate(i).match;
                    if ((c.fn !== null && getMaskSet().validPositions[i] === ba && c.optionality !== true && c.optionalQuantifier !== true) || (c.fn === null && a[i] !== getPlaceholder(i, c))) {
                        b = false;
                        break
                    }
                }
            }
            return b
        }

        function handleRemove(a, k, b, c, d) {
            if (P.numericInput || isRTL) {
                if (k === Inputmask.keyCode.BACKSPACE) {
                    k = Inputmask.keyCode.DELETE
                } else if (k === Inputmask.keyCode.DELETE) {
                    k = Inputmask.keyCode.BACKSPACE
                }
                if (isRTL) {
                    var e = b.end;
                    b.end = b.begin;
                    b.begin = e
                }
            }
            if (k === Inputmask.keyCode.BACKSPACE && (b.end - b.begin < 1 || P.insertMode === false)) {
                b.begin = seekPrevious(b.begin);
                if (getMaskSet().validPositions[b.begin] !== ba && getMaskSet().validPositions[b.begin].input === P.groupSeparator) {
                    b.begin--
                }
                if (P.insertMode === false && b.end !== getMaskSet().maskLength) {
                    b.end--
                }
            } else if (k === Inputmask.keyCode.DELETE && b.begin === b.end) {
                b.end = isMask(b.end, true) && (getMaskSet().validPositions[b.end] && getMaskSet().validPositions[b.end].input !== P.radixPoint) ? b.end + 1 : seekNext(b.end) + 1;
                if (getMaskSet().validPositions[b.begin] !== ba && getMaskSet().validPositions[b.begin].input === P.groupSeparator) {
                    b.end++
                }
            }
            stripValidPositions(b, false, c);
            if (c !== true && (P.keepStatic !== null && P.keepStatic !== false)) {
                var f = alternate(true);
                if (f) b.begin = f.caret !== ba ? f.caret : (f.pos ? seekNext(f.pos.begin ? f.pos.begin : f.pos) : getLastValidPosition(-1, true))
            }
            var g = getLastValidPosition(b.begin, true);
            if (g < b.begin || b.begin === -1) {
                getMaskSet().p = seekNext(g)
            } else if (c !== true) {
                getMaskSet().p = b.begin;
                if (d !== true) {
                    while (getMaskSet().p < g && getMaskSet().validPositions[getMaskSet().p] === ba) {
                        getMaskSet().p++
                    }
                }
            }
        }

        function initializeColorMask(g) {
            var h = (g.ownerDocument.defaultView || Y).getComputedStyle(g, null);

            function findCaretPos(a) {
                var e = Z.createElement("span"),
                    caretPos;
                for (var b in h) {
                    if (isNaN(b) && b.indexOf("font") !== -1) {
                        e.style[b] = h[b]
                    }
                }
                e.style.textTransform = h.textTransform;
                e.style.letterSpacing = h.letterSpacing;
                e.style.position = "absolute";
                e.style.height = "auto";
                e.style.width = "auto";
                e.style.visibility = "hidden";
                e.style.whiteSpace = "nowrap";
                Z.body.appendChild(e);
                var c = g.inputmask._valueGet(),
                    previousWidth = 0,
                    itl;
                for (caretPos = 0, itl = c.length; caretPos <= itl; caretPos++) {
                    e.innerHTML += c.charAt(caretPos) || "_";
                    if (e.offsetWidth >= a) {
                        var d = (a - previousWidth);
                        var f = e.offsetWidth - a;
                        e.innerHTML = c.charAt(caretPos);
                        d -= (e.offsetWidth / 3);
                        caretPos = d < f ? caretPos - 1 : caretPos;
                        break
                    }
                    previousWidth = e.offsetWidth
                }
                Z.body.removeChild(e);
                return caretPos
            }
            var i = Z.createElement("div");
            i.style.width = h.width;
            i.style.textAlign = h.textAlign;
            colorMask = Z.createElement("div");
            g.inputmask.colorMask = colorMask;
            colorMask.className = "im-colormask";
            g.parentNode.insertBefore(colorMask, g);
            g.parentNode.removeChild(g);
            colorMask.appendChild(g);
            colorMask.appendChild(i);
            g.style.left = i.offsetLeft + "px";
            $(colorMask).on("mouseleave", function(e) {
                return S.mouseleaveEvent.call(g, [e])
            });
            $(colorMask).on("mouseenter", function(e) {
                return S.mouseenterEvent.call(g, [e])
            });
            $(colorMask).on("click", function(e) {
                caret(g, findCaretPos(e.clientX));
                return S.clickEvent.call(g, [e])
            });
            $(g).on("keydown", function(e) {
                if (!e.shiftKey && P.insertMode !== false) {
                    setTimeout(function() {
                        renderColorMask(g)
                    }, 0)
                }
            })
        }
        Inputmask.prototype.positionColorMask = function(a, b) {
            a.style.left = b.offsetLeft + "px"
        };

        function renderColorMask(c, d, e) {
            var f = [],
                isStatic = false,
                test, testPos, ndxIntlzr, pos = 0;

            function setEntry(a) {
                if (a === ba) a = "";
                if (!isStatic && (test.fn === null || testPos.input === ba)) {
                    isStatic = true;
                    f.push("<span class='im-static'>" + a)
                } else if (isStatic && ((test.fn !== null && testPos.input !== ba) || test.def === "")) {
                    isStatic = false;
                    var b = f.length;
                    f[b - 1] = f[b - 1] + "</span>";
                    f.push(a)
                } else f.push(a)
            }

            function setCaret() {
                if (Z.activeElement === c) {
                    f.splice(d.begin, 0, (d.begin === d.end || d.end > getMaskSet().maskLength) ? '<mark class="im-caret" style="border-right-width: 1px;border-right-style: solid;">' : '<mark class="im-caret-select">');
                    f.splice(d.end + 1, 0, "</mark>")
                }
            }
            if (colorMask !== ba) {
                var g = getBuffer();
                if (d === ba) {
                    d = caret(c)
                } else if (d.begin === ba) {
                    d = {
                        begin: d,
                        end: d
                    }
                }
                if (e !== true) {
                    var h = getLastValidPosition();
                    do {
                        if (getMaskSet().validPositions[pos]) {
                            testPos = getMaskSet().validPositions[pos];
                            test = testPos.match;
                            ndxIntlzr = testPos.locator.slice();
                            setEntry(g[pos])
                        } else {
                            testPos = getTestTemplate(pos, ndxIntlzr, pos - 1);
                            test = testPos.match;
                            ndxIntlzr = testPos.locator.slice();
                            if (P.jitMasking === false || pos < h || (typeof P.jitMasking === "number" && isFinite(P.jitMasking) && P.jitMasking > pos)) {
                                setEntry(getPlaceholder(pos, test))
                            }
                        }
                        pos++
                    } while ((maxLength === ba || pos < maxLength) && (test.fn !== null || test.def !== "") || h > pos || isStatic);
                    if (isStatic) setEntry();
                    setCaret()
                }
                var i = colorMask.getElementsByTagName("div")[0];
                i.innerHTML = f.join("");
                c.inputmask.positionColorMask(c, i)
            }
        }

        function mask(p) {
            function isElementTypeSupported(k, l) {
                function patchValueProperty(g) {
                    var h;
                    var i;

                    function patchValhook(d) {
                        if ($.valHooks && ($.valHooks[d] === ba || $.valHooks[d].inputmaskpatch !== true)) {
                            var e = $.valHooks[d] && $.valHooks[d].get ? $.valHooks[d].get : function(a) {
                                return a.value
                            };
                            var f = $.valHooks[d] && $.valHooks[d].set ? $.valHooks[d].set : function(a, b) {
                                a.value = b;
                                return a
                            };
                            $.valHooks[d] = {
                                get: function(a) {
                                    if (a.inputmask) {
                                        if (a.inputmask.opts.autoUnmask) {
                                            return a.inputmask.unmaskedvalue()
                                        } else {
                                            var b = e(a);
                                            return getLastValidPosition(ba, ba, a.inputmask.maskset.validPositions) !== -1 || l.nullable !== true ? b : ""
                                        }
                                    } else return e(a)
                                },
                                set: function(a, b) {
                                    var c = $(a),
                                        result;
                                    result = f(a, b);
                                    if (a.inputmask) {
                                        c.trigger("setvalue", [b])
                                    }
                                    return result
                                },
                                inputmaskpatch: true
                            }
                        }
                    }

                    function getter() {
                        if (this.inputmask) {
                            return this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : (getLastValidPosition() !== -1 || l.nullable !== true ? (Z.activeElement === this && l.clearMaskOnLostFocus ? (isRTL ? clearOptionalTail(getBuffer().slice()).reverse() : clearOptionalTail(getBuffer().slice())).join("") : h.call(this)) : "")
                        } else return h.call(this)
                    }

                    function setter(a) {
                        i.call(this, a);
                        if (this.inputmask) {
                            $(this).trigger("setvalue", [a])
                        }
                    }

                    function installNativeValueSetFallback(c) {
                        R.on(c, "mouseenter", function(a) {
                            var b = $(this),
                                k = this,
                                value = k.inputmask._valueGet();
                            if (value !== getBuffer().join("")) {
                                b.trigger("setvalue")
                            }
                        })
                    }
                    if (!g.inputmask.__valueGet) {
                        if (l.noValuePatching !== true) {
                            if (Object.getOwnPropertyDescriptor) {
                                if (typeof Object.getPrototypeOf !== "function") {
                                    Object.getPrototypeOf = typeof "test".__proto__ === "object" ? function(a) {
                                        return a.__proto__
                                    } : function(a) {
                                        return a.constructor.prototype
                                    }
                                }
                                var j = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(g), "value") : ba;
                                if (j && j.get && j.set) {
                                    h = j.get;
                                    i = j.set;
                                    Object.defineProperty(g, "value", {
                                        get: getter,
                                        set: setter,
                                        configurable: true
                                    })
                                } else if (g.tagName !== "INPUT") {
                                    h = function() {
                                        return this.textContent
                                    };
                                    i = function(a) {
                                        this.textContent = a
                                    };
                                    Object.defineProperty(g, "value", {
                                        get: getter,
                                        set: setter,
                                        configurable: true
                                    })
                                }
                            } else if (Z.__lookupGetter__ && g.__lookupGetter__("value")) {
                                h = g.__lookupGetter__("value");
                                i = g.__lookupSetter__("value");
                                g.__defineGetter__("value", getter);
                                g.__defineSetter__("value", setter)
                            }
                            g.inputmask.__valueGet = h;
                            g.inputmask.__valueSet = i
                        }
                        g.inputmask._valueGet = function(a) {
                            return isRTL && a !== true ? h.call(this.el).split("").reverse().join("") : h.call(this.el)
                        };
                        g.inputmask._valueSet = function(a, b) {
                            i.call(this.el, (a === null || a === ba) ? "" : ((b !== true && isRTL) ? a.split("").reverse().join("") : a))
                        };
                        if (h === ba) {
                            h = function() {
                                return this.value
                            };
                            i = function(a) {
                                this.value = a
                            };
                            patchValhook(g.type);
                            installNativeValueSetFallback(g)
                        }
                    }
                }
                var m = k.getAttribute("type");
                var n = (k.tagName === "INPUT" && $.inArray(m, l.supportsInputType) !== -1) || k.isContentEditable || k.tagName === "TEXTAREA";
                if (!n) {
                    if (k.tagName === "INPUT") {
                        var o = Z.createElement("input");
                        o.setAttribute("type", m);
                        n = o.type === "text";
                        o = null
                    } else n = "partial"
                }
                if (n !== false) {
                    patchValueProperty(k)
                } else k.inputmask = ba;
                return n
            }
            R.off(p);
            var q = isElementTypeSupported(p, P);
            if (q !== false) {
                el = p;
                $el = $(el);
                maxLength = el !== ba ? el.maxLength : ba;
                if (maxLength === -1) maxLength = ba;
                if (P.colorMask === true) {
                    initializeColorMask(el)
                }
                if (mobile) {
                    if ("inputmode" in el) {
                        el.inputmode = P.inputmode;
                        el.setAttribute("inputmode", P.inputmode)
                    }
                    if (P.disablePredictiveText === true) {
                        if ("autocorrect" in el) {
                            el.autocorrect = false
                        } else {
                            if (P.colorMask !== true) {
                                initializeColorMask(el)
                            }
                            el.type = "password"
                        }
                    }
                }
                if (q === true) {
                    R.on(el, "submit", S.submitEvent);
                    R.on(el, "reset", S.resetEvent);
                    R.on(el, "blur", S.blurEvent);
                    R.on(el, "focus", S.focusEvent);
                    if (P.colorMask !== true) {
                        R.on(el, "click", S.clickEvent);
                        R.on(el, "mouseleave", S.mouseleaveEvent);
                        R.on(el, "mouseenter", S.mouseenterEvent)
                    }
                    R.on(el, "dblclick", S.dblclickEvent);
                    R.on(el, "paste", S.pasteEvent);
                    R.on(el, "dragdrop", S.pasteEvent);
                    R.on(el, "drop", S.pasteEvent);
                    R.on(el, "cut", S.cutEvent);
                    R.on(el, "complete", P.oncomplete);
                    R.on(el, "incomplete", P.onincomplete);
                    R.on(el, "cleared", P.oncleared);
                    if (!mobile && P.inputEventOnly !== true) {
                        R.on(el, "keydown", S.keydownEvent);
                        R.on(el, "keypress", S.keypressEvent)
                    } else {
                        el.removeAttribute("maxLength")
                    }
                    R.on(el, "compositionstart", $.noop);
                    R.on(el, "compositionupdate", $.noop);
                    R.on(el, "compositionend", $.noop);
                    R.on(el, "keyup", $.noop);
                    R.on(el, "input", S.inputFallBackEvent);
                    R.on(el, "beforeinput", $.noop)
                }
                R.on(el, "setvalue", S.setValueEvent);
                undoValue = getBufferTemplate().join("");
                if (el.inputmask._valueGet(true) !== "" || P.clearMaskOnLostFocus === false || Z.activeElement === el) {
                    var r = $.isFunction(P.onBeforeMask) ? (P.onBeforeMask.call(Q, el.inputmask._valueGet(true), P) || el.inputmask._valueGet(true)) : el.inputmask._valueGet(true);
                    if (r !== "") checkVal(el, true, false, isRTL ? r.split("").reverse() : r.split(""));
                    var s = getBuffer().slice();
                    undoValue = s.join("");
                    if (isComplete(s) === false) {
                        if (P.clearIncomplete) {
                            resetMaskSet()
                        }
                    }
                    if (P.clearMaskOnLostFocus && Z.activeElement !== el) {
                        if (getLastValidPosition() === -1) {
                            s = []
                        } else {
                            clearOptionalTail(s)
                        }
                    }
                    writeBuffer(el, s);
                    if (Z.activeElement === el) {
                        caret(el, seekNext(getLastValidPosition()))
                    }
                }
            }
        }
        var T;
        if (N !== ba) {
            switch (N.action) {
                case "isComplete":
                    el = N.el;
                    return isComplete(getBuffer());
                case "unmaskedvalue":
                    if (el === ba || N.value !== ba) {
                        T = N.value;
                        T = ($.isFunction(P.onBeforeMask) ? (P.onBeforeMask.call(Q, T, P) || T) : T).split("");
                        checkVal(ba, false, false, isRTL ? T.reverse() : T);
                        if ($.isFunction(P.onBeforeWrite)) P.onBeforeWrite.call(Q, ba, getBuffer(), 0, P)
                    }
                    return unmaskedvalue(el);
                case "mask":
                    mask(el);
                    break;
                case "format":
                    T = ($.isFunction(P.onBeforeMask) ? (P.onBeforeMask.call(Q, N.value, P) || N.value) : N.value).split("");
                    checkVal(ba, true, false, isRTL ? T.reverse() : T);
                    if (N.metadata) {
                        return {
                            value: isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join(""),
                            metadata: maskScope.call(this, {
                                "action": "getmetadata"
                            }, O, P)
                        }
                    }
                    return isRTL ? getBuffer().slice().reverse().join("") : getBuffer().join("");
                case "isValid":
                    if (N.value) {
                        T = N.value.split("");
                        checkVal(ba, true, true, isRTL ? T.reverse() : T)
                    } else {
                        N.value = getBuffer().join("")
                    }
                    var U = getBuffer();
                    var V = determineLastRequiredPosition(),
                        lmib = U.length - 1;
                    for (; lmib > V; lmib--) {
                        if (isMask(lmib)) break
                    }
                    U.splice(V, lmib + 1 - V);
                    return isComplete(U) && N.value === getBuffer().join("");
                case "getemptymask":
                    return getBufferTemplate().join("");
                case "remove":
                    if (el && el.inputmask) {
                        $.data(el, "_inputmask_opts", null);
                        $el = $(el);
                        el.inputmask._valueSet(P.autoUnmask ? unmaskedvalue(el) : el.inputmask._valueGet(true));
                        R.off(el);
                        if (el.inputmask.colorMask) {
                            colorMask = el.inputmask.colorMask;
                            colorMask.removeChild(el);
                            colorMask.parentNode.insertBefore(el, colorMask);
                            colorMask.parentNode.removeChild(colorMask)
                        }
                        var W;
                        if (Object.getOwnPropertyDescriptor && Object.getPrototypeOf) {
                            W = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(el), "value");
                            if (W) {
                                if (el.inputmask.__valueGet) {
                                    Object.defineProperty(el, "value", {
                                        get: el.inputmask.__valueGet,
                                        set: el.inputmask.__valueSet,
                                        configurable: true
                                    })
                                }
                            }
                        } else if (Z.__lookupGetter__ && el.__lookupGetter__("value")) {
                            if (el.inputmask.__valueGet) {
                                el.__defineGetter__("value", el.inputmask.__valueGet);
                                el.__defineSetter__("value", el.inputmask.__valueSet)
                            }
                        }
                        el.inputmask = ba
                    }
                    return el;
                    break;
                case "getmetadata":
                    if ($.isArray(O.metadata)) {
                        var X = getMaskTemplate(true, 0, false).join("");
                        $.each(O.metadata, function(a, b) {
                            if (b.mask === X) {
                                X = b;
                                return false
                            }
                        });
                        return X
                    }
                    return O.metadata
            }
        }
    }
    return Inputmask
}));
(function(a) {
    if (typeof define === "function" && define.amd) {
        define(["jquery", "./inputmask"], a)
    } else if (typeof exports === "object") {
        module.exports = a(require("jquery"), require("./inputmask"))
    } else {
        a(jQuery, window.Inputmask)
    }
}(function($, d) {
    if ($.fn.inputmask === undefined) {
        $.fn.inputmask = function(a, b) {
            var c, input = this[0];
            if (b === undefined) b = {};
            if (typeof a === "string") {
                switch (a) {
                    case "unmaskedvalue":
                        return input && input.inputmask ? input.inputmask.unmaskedvalue() : $(input).val();
                    case "remove":
                        return this.each(function() {
                            if (this.inputmask) this.inputmask.remove()
                        });
                    case "getemptymask":
                        return input && input.inputmask ? input.inputmask.getemptymask() : "";
                    case "hasMaskedValue":
                        return input && input.inputmask ? input.inputmask.hasMaskedValue() : false;
                    case "isComplete":
                        return input && input.inputmask ? input.inputmask.isComplete() : true;
                    case "getmetadata":
                        return input && input.inputmask ? input.inputmask.getmetadata() : undefined;
                    case "setvalue":
                        d.setValue(input, b);
                        break;
                    case "option":
                        if (typeof b === "string") {
                            if (input && input.inputmask !== undefined) {
                                return input.inputmask.option(b)
                            }
                        } else {
                            return this.each(function() {
                                if (this.inputmask !== undefined) {
                                    return this.inputmask.option(b)
                                }
                            })
                        }
                        break;
                    default:
                        b.alias = a;
                        c = new d(b);
                        return this.each(function() {
                            c.mask(this)
                        })
                }
            } else if (typeof a == "object") {
                c = new d(a);
                if (a.mask === undefined && a.alias === undefined) {
                    return this.each(function() {
                        if (this.inputmask !== undefined) {
                            return this.inputmask.option(a)
                        } else c.mask(this)
                    })
                } else {
                    return this.each(function() {
                        c.mask(this)
                    })
                }
            } else if (a === undefined) {
                return this.each(function() {
                    c = new d(b);
                    c.mask(this)
                })
            }
        }
    }
    return $.fn.inputmask
}));